

# 期末架构

## 第10章 持续集成

### 10.1、持续集成基础概念

#### 持续集成介绍

1.持续集成

- 让产品可以快速迭代，同时还能保持高质量，简化工作流程。

2.持续交付

- 让测试通过后的代码，可以准备用于部署
- 持续交付，重复前者所有的操作。

3.持续部署

- 基于交付集成之上，无论何时，代码都确保可以部署，且是自动化的。

4.持续集成实现的思路（git、jenkins、shell）

5.版本控制系统

- 将文件的每一次变化，集中在一个系统中加以版本记录，以便后续查阅文件的历史记录。





#### 版本控制系统

- 常见版本控制系统
  - SVN ，集中式
  - Git，分布式
- git版本控制
  - 基本使用
  - git与github关联
- 代码托管平台
  - github
  - gitlab
    - 配置域名
    - 配置邮箱
    - gitlab基本使用
    - gitlab的用户组、用户、项目
    - gitlab基本运维、备份、恢复
- jenkins
  - jenkins是什么，干什么的，为什么要学它
  - jenkins安装、汉化
  - jenkins插件、加速插件、安装插件、导入本地插件
  - jenkins项目创建，自由风格项目，以及jenkins-shell
  - jenkins+gitlab
  - 手动搭建一套集群环境，然后实现代码上线
  - jenkins构建项目，html，php
  - jenkins构建项目脚本开发，部署、回滚
  - jenkins构建Java项目，编译、部署（jar，war）
  - jenkins通知功能
    - 邮件
    - 钉钉
  - 拿到源代码后，对源码进行质量扫描
    - SonarQube
      - 安装
      - 手动推代码至Sonarqube测试
      - jenkins集成SOnarqube
- jenkins流水线pipeline
  - pipeline语法
  - pipeline实现html项目流水线部署
  - pipeline实现java项目流水线部署
- jenkins分布式构建
- jenkins权限控制



#### 什么是集成

在实际软件开发中，常会有如下两种场景：

1.现在有一个电商平台需要开发，由于电商平台模块众多，此时就需要不同开发人员开发不同的模块，最红把所有人的代码都集中到一个系统中。集成后对其进行部署上线。

2.随着时间的推移，无论是修复bug还是新功能开发，后续都要对系统进行不断的更新、迭代。

![image-20200706111309218](.\notes\image-20200706111309218.png)

#### 什么是持续集成（CI）

持续集成（Continuous integration ，CI）

持续集成就是在于”持续“两字，频繁的（一天多次）的将代码集成到主干(master)，重复如上的工作。

![image-20200706111723922](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706111723922.png)

```shel
程序员
    ↓推代码
git仓库，gitlab
    ↓仓库通知CI服务器，jenkins
jenkins执行脚本，如对代码编译，测试，运行
    ↓通知集成结果
程序员对结果处理
```

#### 使用持续集成好处

1.快速发现错误，每完成一点更新，就集成到主干，可以快速发现bug，也容易定位错误。

2.节省人力成本，省去手动反复部署操作

3.加快软件开发进程

4.实时交付

5.防止大幅度偏离主干，如果不经常集成，主干也在更新，会导致后续集成难度增大，或是难以集成。

#### 使用持续集成目的

让产品可以快速迭代，同时还能保持高质量。（程序员写了新功能，很可能有bug，快速进行jenkins集成测试，能够快速发现bug，定位、解决bug，再次集成操作，整个过程自动化，非常高效且省时省力）

持续集成核心目的：代码集成到主干之前，对代码进行自动化测试。只要有一个测试用例失败，就不能集成，当然持续集成并不能完全的消除bug，主要目的是让bug更容易发现和改正。





#### 什么情况需要持续集成

如果项目开发的规模较小，软件集成不是问题。

如果项目很大，需要不断添加新功能，或不断的升级产品，则需要进行反复集成，因此必须使用持续集成来简化工作。



#### 持续交付（CD）

Continuous Delivery

交付，产品从开始到结束诞生的产物，在服务器上健康运行。

持续交付指的是在持续集成的环境基础之上，将代码部署到预生产环境。

- 持续集成对代码进行集成测试
- 持续交付，对代码进行部署





#### 持续交付过程

![image-20200706113538981](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706113538981.png)

- 代码开发
  - 开发自己单元测试
- 代码合并到主干
- 测试人员介入，功能测试、自动化测试
- 代码进行生产部署，jenkins一键自动化部署





#### 持续部署(CD)

Continuous Deployment

持续部署是持续交付的下一步，指代码在任何时刻都是可部署的，最后将部署到生产环境的过程自动化。

持续部署和持续交付的区别就在于最终部署到生产环境`是自动化的`。

#### 持续部署过程

![image-20200706133434092](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200706133434092.png)

```
当有人提交了代码，就自动的通知jenkins对代码进行构建 > 测试 > 确认代码可运行  > 构建到生产服务器 
整个过程全自动化，但是有可能出现难以预料的问题
最好的是半自动化，使用持续交付
```



#### 持续集成实施流程

根据持续集成的设计，代码从提交到进入生产环境，整个过程如下：

![image-20200706134430359](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200706134430359.png)



### 10.2、版本控制



#### 关于版本控制

什么是“版本控制”？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

#### 本地版本控制系统

许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。

如果你在学校写过毕业论文，那你一定遇见过这样的问题

![image-20200706140045980](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706140045980.png)

一个论文翻来覆去的改，写一点觉得有问题，写一点还觉得有问题，还不容易写好了，导师还挑刺，说这改的还不如上回，给改回去、、、

![image-20200706140059421](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706140059421.png)

- **看着这一堆乱七八糟的文件，你自己也不记得，每一个文件到底写了什么内容，还得一个个看，想删又不敢删。。。**
- **当你写完了毕业论文，你还得用U盘拷给导师，或者发个邮件给他，但是你回家可能还得改论文，那你发给导师的论文和你本地最新的论文又不一致了。。**

**于是这么多令人fuck指的操作，你就希望有没有一个软件，帮你记录文件变动的操作，并且同事还能一起操作，不需要自己传输文件，想知道变动了什么，只需要去软件里看看，这是不是很nb？**

#### 这个软件雏形？

对于文件使用版本号，日期的管理，这种方式比起没有版本管理好得多，但是也很臃肿，且他人不容易看得懂

| 版本 | 文件名                     | 用户    | 说明               | 日期       |
| ---- | -------------------------- | ------- | ------------------ | ---------- |
| 1    | 美国皇家大学毕业论文v1.doc | yuchao  | 论文初稿           | 7/12 10:38 |
| 2    | 美国皇家大学毕业论文v2.doc | yuchao  | 论文修改版         | 7/12 18:09 |
| 3    | 美国皇家大学毕业论文v3.doc | Onlyu   | 小于帮我修改论文   | 7/13 9:51  |
| 4    | 美国皇家大学毕业论文v4.doc | Wupeiqi | 武沛奇帮我修改论文 | 7/14 15:17 |

#### 新式版本控制

现在的版本控制系统又是如何管理的，且还能实现快速回退功能。

![image-20200706141239759](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706141239759.png)

#### 版本控制系统解决了什么问题

1.追溯文件历史变更记录

2.多人团队协同开发

3.代码集中统一管理



### 10.3、版本管理工具介绍

#### Git工具

![image-20200706142149787](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142149787.png)

![image-20200706142200211](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142200211.png)

![image-20200706142213781](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142213781.png)

#### 集中式和分布式版本控制

Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？

先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。

![image-20200706142259460](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142259460.png)

集中式版本控制，典型代表SVN

集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。

**而且如果集中式版本服务器宕机了，所有人都没法工作。**

![image-20200706142336822](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142336822.png)

#### 分布式版本控制

分布式版本控制，没有中央服务器的概念，每个人都有自己的版本库，因此每个人在工作时候，**不需要联网，版本库本地即可管理。**

既然每个人都是一个完整的版本库，同事之间如果需要协作开发，就需要找一个用于“交换文件”的中央服务器，这个服务器不存在也不影响大家干活，只是用于交换文件内容。

GIT最强大的功能还有分支管理，远甩SVN等软件。

![image-20200706142430538](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142430538.png)

![image-20200706142441716](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142441716.png)

![image-20200706142457030](C:\Users\admin\Desktop\笔记\期末架构\notes\image-20200706142457030.png)





### 10.4、Git工具安装



#### 命令行

Git有多重方式使用

- 原生命令行，才能使用git所有命令，会git命令再去用gui图形工具，完全无压力
- GUI图形软件，只是实现了git的部分功能，以减免操作难度，难以记住git原生命令
- 不同的人会有不同的GUI图形工具，但是所有人用的git原生命令都一样，推荐学习命令

#### Windows安装

在Windows上使用Git，可以从Git官网直接[下载安装程序](https://git-scm.com/downloads)，然后按默认选项安装即可。

安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！

#### 在 Mac 上安装

在mac安装git方式很多，最简单是用brew包管理

安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。

```shell
brew install git
```

如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 http://git-scm.com/download/mac。

#### 在 Linux 上安装

如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以Centos 上为例，你可以使用 yum：

```shell
sudo yum install git
```

如果你在基于 Debian 的发行版上，请尝试用 apt-get：

```shell
sudo apt-get install git
```





#### 环境准备

准备好一台linux机器，且进行环境初始化，主机名、配置yum源、安装基础软件包、关闭防火墙、同步系统时间等。

安装git

```shell
[root@git-server /]# yum install git -y


[root@git-server /]# git --version
git version 1.8.3.1

```

#### 运行git前的配置

既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次，程序升级时会保留配置信息。 你可以在任何时候再次通过运行命令来修改它们。

Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：

**这个用户指的是linux用户**

三种环境参数

- **--system**
- **--global**
- **--local**
- `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 `--system` 选项的 `git config` 时，它会从此文件读写配置变量。
- `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 可以传递 `--global` 选项让 Git 读写此文件。
- 当前使用仓库的 Git 目录中的 `config` 文件（就是 `.git/config`）：针对该仓库。 `--local` 当前仓库配置





#### 用户信息配置

通常配置git，只需要配置好你是谁，你的邮箱，这样就知道是谁在提交代码了。

```shell
git config --global user.name "syh"

git config --global user.email "17688702764@163.com"

git config --global color.ui true


我们这里配置的是--global参数，因此是在用户家目录下，可以查看
[root@chaogelinux ~]# cat .gitconfig
[user]
    name = pyyu
    email = yc_uuu@163.com
[color]
    ui = true[root@git-server ~]#  cat .gitconfig
[user]
	name = syh
	email = 17688702764@163.com
[color]
	ui = true
```



#### Git配置相关命令

```shell
yum install git -y  安装git

git --version　　查看git版本

git config --system --list 查看系统所有linux用户的通用配置,此命令检查/etc/gitconfig

git config --global --list 查看当前linux用户的配置，检查~/.gitconfig文件

git config --local --list 查看git目录中的仓库配置文件，.git/config文件

git config --global user.name "pyyu"　　配置当前linux用户全局用户名，这台机器所有git仓库都会用这个配置

git config --global user.email "yc_uuu@163.com"  配置当前linux用户全局邮箱

git config --global color.ui true 配置git语法高亮显示

git config --list 列出git能找到的所有配置,从不同的文件中读取所有结果

git config user.name　　列出git某一项配置

git help 获取git帮助

man git man手册

git help config 获取config命令的手册
```









### 10.5、Git的工作流程

#### Git工作流程

#### Git四个区域

使用git就是将本地文件（工作目录workspace）的文件，添加到暂存区（stage）,然后提交到本地仓库（repository），最终可以协同开发，推送到远程仓库（remote）。

![image-20200706152248954](notes/image-20200706152248954.png)

#### Git实践

git版本库，也叫做git仓库（repository），也就是一个文件夹。

这个目录的所有内容被git软件管理，所有的修改，删除，git都会跟踪记录，便于可以跟踪历史记录，以后可以还原文件。



#### 三种场景需求：

##### 1.把已有的项目代码，纳入git管理

```shell
cd mysite    mysite项目所在代码  （工作目录）
git init        初始化git仓库

例子：
[root@git-server ~]# mkdir mygit
[root@git-server mygit]# git init
初始化空的 Git 版本库于 /root/mygit/.git/

[root@git-server mygit]# cd .git/
[root@git-server .git]# ll
总用量 12
drwxr-xr-x 2 root root   6 11月 15 21:13 branches
-rw-r--r-- 1 root root  92 11月 15 21:13 config
-rw-r--r-- 1 root root  73 11月 15 21:13 description
-rw-r--r-- 1 root root  23 11月 15 21:13 HEAD
drwxr-xr-x 2 root root 242 11月 15 21:13 hooks
drwxr-xr-x 2 root root  21 11月 15 21:13 info
drwxr-xr-x 4 root root  30 11月 15 21:13 objects
drwxr-xr-x 4 root root  31 11月 15 21:13 refs



git init命令会创建一个.git隐藏子目录，这个目录包含初始化git仓库所有的核心文件。
此步仅仅是初始化，此时项目里的代码还没有被git跟踪，因此还需要git add对项目文件跟踪，然后git commit提交到本地仓库
```

想知道.git文件做了什么事，请看git原理 >[Git 内部原理](https://git-scm.com/book/zh/v2/ch00/ch10-git-internals)





##### 2.新建一个项目，直接用git管理

```shell
cd 某个文件夹
git init mygit      此步会在当前路径创建mygit 文件夹，mygit文件夹中包含了.git的初始化文件夹，所有配置
```

.git这个目录中

```shell
[root@pyyuc ~/git_learning/mysite 11:08:19]#tree .git
.git
├── branches
├── config　　　　这个项目独有的配置
├── description
├── HEAD　　　　head文件指示目前被检出的分支
├── hooks　　hooks目录包含服务端和客户端的钩子脚本 hook scripts
│   ├── applypatch-msg.sample
│   ├── commit-msg.sample
│   ├── post-update.sample
│   ├── pre-applypatch.sample
│   ├── pre-commit.sample
│   ├── prepare-commit-msg.sample
│   ├── pre-push.sample
│   ├── pre-rebase.sample
│   └── update.sample
├── index  index文件保存暂存区的信息，只有git add之后才会生成，默认还没有这个文件
├── info　　　　info目录是全局性排除文件，用于放置不想被记录在.gitignore文件中的忽略模式（ignored patterns）
│   └── exclude
├── objects　　存储所有数据内容
│   ├── info
│   └── pack
└── refs　　refs目录存储指向数据（分支）的提交对象的指针
    ├── heads
    └── tags

.git文件夹解析
```





##### 3.获取远程代码仓库代码

```shell
如果你想获取github上的代码，或者你公司gitlab私有仓库的代码，可以使用git clone命令，下载克隆远程仓库的代码。

git clone https://github.com/django/django.git
下载出来的代码已经是被git管理的本地仓库
你会发现所有的项目文件都在这里，等待后续开发
```





### 10.6、Git初始化仓仓库

#### Git生命周期演练

##### git工作区

在我们进行git init mygit初始化一个git项目时，这个mygit文件夹，就是一个工作区（working Directory）

```shell
[root@git-server mygit]# pwd
/root/mygit

[root@git-server mygit]# touch test
[root@git-server mygit]# ls -a
.  ..  .git  test
```





##### git仓库

工作区里有一个.git隐藏文件夹，就是git的本地仓库

.git文件夹里有一个index文件，就是git的暂存区，也叫做stage

.git文件夹里的HEAD文件就是git的一个指针

原理图

![image-20200706162526177](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200706162526177.png)

```shell
git init mysite                          初始化git仓库

git status                                 查看git状态

echo 'print("挣了一个亿")' > main.py        新建一个代码文件，此时是未被git跟踪的

git status                                查看状态

    On branch master

    No commits yet

    Untracked files:
      (use "git add <file>..." to include in what will be committed)

        main.py

    nothing added to commit but untracked files present (use "git add" to track)

git add main.py　　开始跟踪main.py文件

git status 　　此时再看已经被跟踪，现在已是可以被提交的状态,此时处于暂存区

git commit -m "echo main.py"  告诉git，把暂存区的main.py提交到本地仓库

git log 　　　　查看刚才的commit记录
```



##### 检查git文件状态

```shell
git status 
此命令查看git工作目录的文件，处于生命周期的哪一个状态 注意，只能在git工作目录中输入这个命令，他会去找.git文件夹 
第一次输入git status会看到此状态，没有任何东西需要提交
[root@pyyuc ~/git_learning/mysite 12:00:34]#git status
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)

说明当前工作目录很干净，所有的已跟踪文件，已经被提交且未更改。
此时处在master默认分支。
```





### 10.7、Git基础命令之git mv



#### 给文件重命名

```shell
我们还是在git版本库中操作
修改main.py为mymain.py
mv main.py  mymain.py
查看状态
git status直接mv的操作，会被git记录为两个形容，一、删除原有文件、二、新建了mymain.py文件此时新文件还未被跟踪，需要git add , git commit原本的main.py还需要从暂存区删除
[root@pyyuc ~/mysite 14:57:57]#git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    deleted:    main.py
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    mymain.py
no changes added to commit (use "git add" and/or "git commit -a")git rm main.py　　删除暂存区的main.pygit commit -m "mv mymain.py"　　提交新的mymain.py



例子：
[root@git-server mygit]# ls
a
[root@git-server mygit]# mv a b

#查看暂存区状态
[root@git-server mygit]# git status 
# 位于分支 master
# 尚未暂存以备提交的变更：
#   （使用 "git add/rm <file>..." 更新要提交的内容）
#   （使用 "git checkout -- <file>..." 丢弃工作区的改动）
#
#	删除：      a
#
# 未跟踪的文件:
#   （使用 "git add <file>..." 以包含要提交的内容）
#
#	b
修改尚未加入提交（使用 "git add" 和/或 "git commit -a"）


#此时要添加新的新的文件b到暂存区、以及将a从暂存区删除
[root@git-server mygit]# git rm a
rm 'a'
[root@git-server mygit]# git status 
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	删除：      a
#
# 未跟踪的文件:
#   （使用 "git add <file>..." 以包含要提交的内容）
#
#	b


#再将b重新添加到暂存区
[root@git-server mygit]# git add b
[root@git-server mygit]# git status 
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	重命名：    a -> b

#最后再从暂存区提交到本地仓库
[root@git-server mygit]# git commit -m "mv a to b"
[master 8b841c8] mv a to b
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename a => b (100%)
[root@git-server mygit]# git status 
# 位于分支 master
无文件要提交，干净的工作区							#这里提示干净、说明工作目录、暂存区、本地仓库的内容已经一致了


```



这样的步骤很麻烦，可以直接git mv 命令即可

刚才的mv记录，可以通过git log查看历史记录，已经提交的id

可以通过git reset 回退历史版本，回退到改名之前

```shell
[root@git-server mygit]# git log
commit 8b841c8fa7ec58bfd6e5446874294cb0d0d315be
Author: syh <17688702764@163.com>
Date:   Mon Nov 16 11:32:43 2020 +0800

    mv a to b

commit 18c2cc183a247e902f87bc284d0a1102b0f60c82
Author: syh <17688702764@163.com>
Date:   Mon Nov 16 11:28:20 2020 +0800

    mv a



回退到上一次commit版本，（注意这个命令，很危险，慎用）
git reset --hard 65e0a2239909fd5aabc5928ec4431de3f163a195 
--hard 清空暂存区和工作目录资料
```



文件改名正确姿势

```shell

[root@git-server mygit]# git mv b c				#git mv做了两件事、1是将原来的b从暂存区剔除、将新的c重新添加到暂存区


[root@git-server mygit]# git status
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	重命名：    b -> c


[root@git-server mygit]# git commit -m "mv b to c"
[master 3ace0bb] mv b to c
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename b => c (100%)

[root@git-server mygit]# git status
# 位于分支 master
无文件要提交，干净的工作区



#回退到上一次commit版本，（注意这个命令，很危险，慎用）
[root@git-server mygit]# git reset --hard
HEAD 现在位于 3ace0bb mv b to c
--hard 清空暂存区和工作目录资料

```



### 10.8、Git基础命令之git log

#### git版本历史

在我们使用git的时候，会对代码文件不停的修改，不断的提交到代码仓库。

这个就如同我们打游戏时候，保存关卡记录的操作。

![image-20200706162827184](notes/image-20200706162827184.png)

在打boss之前，先做一个存档，防止你这个渣渣，被boss一招秒杀，又得从头再来。。。。。

因此被boss弄死，可以从存档，重新开始游戏。。。。

#### git log

**当你的代码写好了一部分功能，就可以保存一个"存档"，这个存档操作就是git commit，如果代码出错，可以随时回到"存档"记录**

**查看"存档"记录，查看commit提交记录的命令 git log**

我们可以吧git commit操作与虚拟机的快照做对比理解，简单理解就是每次commit，就等于我们对代码仓库做了一个快照。

可以演示下vmware快照

那么我们如何知道文件快照了多少次呢？

git log命令显示，从最新的commit记录到最远的记录顺序。

```shell
git log --oneline    一行显示git记录
git log --oneline  --all  一行显示所有分支git记录
git log --oneline --all -4 --graph 显示所有分支的版本演进的最近4条
git log -4  显示最近4条记录
git log --all     显示所有分支的commit信息

git branch -v 查看分支信息
git help --web log 以web界面显示log的参数
```





### 10.9、Git基础命令之git diff

我们先记住如下几个命令的作用：

- git diff：
  - 当工作区有改动，暂存区为空，diff比较的是`工作区`和`最后一次commit提交的仓库`的共同文件
  - 当工作区有改动，暂存区不为空，diff比较的是`工作区`和`暂存区`的共同文件
- git diff --cached或git diff --staged
  - 显示`暂存区`（已add但未commit的文件）和`最后一次commit`之间所有的不相同的文件，增删改信息。
- git diff HEAD：
  - 显示工作区（已跟踪但未add的文件）和暂存区（已add但未commit的文件）和本地仓库(最后一次commit的文件)所有不相同文件的增删改。





#### 命令实践

情况一：工作区，暂存区，都没有改动

```shell
# 情况一，工作区，暂存区，都没有改动
[root@git-server mygit]# ls
c
[root@git-server mygit]# git status
# 位于分支 master
无文件要提交，干净的工作区
[root@git-server mygit]# git diff

```

情况二：工作区有改动，暂存区为空（未git add的情况），比较的是工作区和本地仓库

```shell
# 情况二，工作区有改动，暂存区为空（未git add的情况），比较的是工作区和本地仓库
[root@git-server mygit]# ls
c

[root@git-server mygit]# echo "hello">c

[root@git-server mygit]# git status
# 位于分支 master
# 尚未暂存以备提交的变更：
#   （使用 "git add <file>..." 更新要提交的内容）
#   （使用 "git checkout -- <file>..." 丢弃工作区的改动）
#
#	修改：      c
#
修改尚未加入提交（使用 "git add" 和/或 "git commit -a"）
[root@git-server mygit]# diff


[root@git-server mygit]# git diff
diff --git a/c b/c
index e69de29..ce01362 100644
--- a/c
+++ b/c
@@ -0,0 +1 @@
+hello
#此时比较的是工作目录与暂存区的内容
```



情况三：工作区有改动，暂存区不为空，比较的是工作区和本地仓库

```shell
# 情况三，工作区有改动，暂存区不为空，比较的是工作区和本地仓库

#将工作目录所有内容添加到暂存区
[root@git-server mygit]# git add .

#工作目录yu暂存区内容一致、所以比较无结果
[root@git-server mygit]# git diff


#此时在本地文件做些修改
[root@git-server mygit]# echo 'my name is syh'>>c


#此时暂存区不为空
[root@git-server mygit]# git status
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	修改：      c
#
# 尚未暂存以备提交的变更：
#   （使用 "git add <file>..." 更新要提交的内容）
#   （使用 "git checkout -- <file>..." 丢弃工作区的改动）
#
#	修改：      c
#

#再次比较
[root@git-server mygit]# git diff c
diff --git a/c b/c
index ce01362..6a7a879 100644
--- a/c
+++ b/c
@@ -1 +1,2 @@
 hello
+my name is syh
#发现还是比较工作目录和暂存区的内容

#将新添加的内容加到暂存区
[root@git-server mygit]# git add .
[root@git-server mygit]# git status
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	修改：      c
#

#将暂存区的内容加到本地仓库
[root@git-server mygit]# git commit -m 'modify c'
[master f0f56d4] modify c
 1 file changed, 2 insertions(+)
[root@git-server mygit]# git status
# 位于分支 master
无文件要提交，干净的工作区

```

情况四：刚才比较的都是本地工作区的文件区别，现在比较`暂存区`和`本地仓库`的区别

```shell
# 案例1，当前暂存区为空
[root@git-server mygit]# git status
# 位于分支 master
无文件要提交，干净的工作区

#直接比较暂存区与本地仓库，是没有区别的
[root@git-server mygit]# git diff --cached


#现在修改本地文件、加入到暂存区但不上传到本地仓库
[root@git-server mygit]# echo 'git diff 确实强大'>>c
[root@git-server mygit]# git add .
[root@git-server mygit]# git status
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	修改：      c
#


# 使用git diff查看git diff --cached区别
# 直接git diff没有结果，因为比较的是工作区和暂存区信息，是一样的，已经git add了
[root@git-server mygit]# git diff

[root@git-server mygit]# git diff --cached
diff --git a/c b/c
index 6a7a879..073f0b9 100644
--- a/c
+++ b/c
@@ -1,2 +1,3 @@
 hello
 my name is syh
+git diff 确实强大


```

情况五：比较所有区域的区别

git diff head：

- 显示工作区（已跟踪但未add的文件）和暂存区（已add但未commit的文件）和本地仓库(最后一次commit的文件)所有不相同文件的增删改。

```shell
# 所有区域没有内容变化，没有结果
[root@git-server mygit]# git diff HEAD


# 工作区有内容变化，和本地仓库有文件差异；这里工作区又变化、但暂存区未更新、本地仓库也未提交；
[root@git-server mygit]# echo "工作目录有变化了，但没commit">>c
[root@git-server mygit]# 
[root@git-server mygit]# git diff HEAD
diff --git a/c b/c
index 073f0b9..b8de2bb 100644
--- a/c
+++ b/c
@@ -1,3 +1,4 @@
 hello
 my name is syh
 git diff 确实强大
+工作目录有变化了，但没commit


# 工作区，暂存区，本地仓库三个比较，仍有区别;
[root@git-server mygit]# git add .
[root@git-server mygit]# git diff HEAD
diff --git a/c b/c
index 073f0b9..b8de2bb 100644
--- a/c
+++ b/c
@@ -1,3 +1,4 @@
 hello
 my name is syh
 git diff 确实强大
+工作目录有变化了，但没commit


# 提交暂存区后，所有区域没有区别了
[root@git-server mygit]# git commit -m 'modify c'
[master 86c76ed] modify c
 1 file changed, 1 insertion(+)
[root@git-server mygit]# git diff HEAD

```

总结，看来`git diff head`能最大程度的检查出git区域间的文件一致。

| git命令           | 情景                            | 作用                                   | 结果         |
| ----------------- | ------------------------------- | -------------------------------------- | ------------ |
| git diff          | 工作区、暂存区都无改变          | 三个区域内容一致                       | 无           |
|                   | 工作区改变、暂存区无改变(未add) | 比较工作区与本地仓库的内容差异         | 显示改变内容 |
|                   | 工作区改变、暂存区改变(已add)   | 比较工作区与本地仓库的内容差异         | 显示改变内容 |
| git  diff -cached | 工作区改变、暂存区改变(已add)   | 比较暂存区与本地仓库的内容差异         | 显示改变内容 |
| git diff HEAD     | 工作区改变、暂存区未add         | 比较工作区与本地仓库的内容差异         | 显示改变内容 |
|                   | 工作区改变、暂存区已add         | 比较工作区或暂存区与本地仓库的内容差异 | 显示改变内容 |
|                   |                                 |                                        |              |



### 10.10、git仓库管理生命周期

#### git仓库文件管理生命周期

```shell
还记得git的四个区域吗？本地文件夹，暂存区，本地仓库，远程仓库吗？

本地文件夹未初始化，git是不认识的

本地文件git init后，就成了git仓库
```

请记住，在工作文件夹的每一个文件，只有两种状态，一个是`未跟踪`，一个是`已跟踪`

已跟踪的指的是已经被纳入git版本管理的文件，在git快照中有他的记录

未跟踪的是这个文件既不在git快照中，也不在暂存区

git init初始化时的工作文件夹，都属于已跟踪了，后续的编辑操作都会标记为，已修改文件，因此需要将修改后的文件，加入暂存区，然后提交暂存区的文件。

![image-20200706174126694](notes/image-20200706174126694.png)





### 10.11、Git版本回退



#### Git版本回退

学到这里，超哥想起来那年十八岁，听着周董的《回到过去》。。

![image-20200706174453642](notes/image-20200706174453642.png)

我们已知git commit可以提交代码到本地仓库，如同虚拟机的快照，当也可以进行版本回退。

```shell
git log可以查看历史版本记录
git reset --hard命令可以回退版本
git reset --hard HEAD^ 回退到上个版本
HEAD表示当前版版本
HEAD^表示上个版本
HEAD^^上上个版本

也可以直接git reset --hard 版本id号

这个时候就发现，git commit -m 所标记的注释信息非常重要了吧
```

#### 版本回退原理

```shell
[root@git-server test_git]# git log --oneline
5c90733 commite test2.txt
a6b42d8 commite test1.txt


#现在我想回退到提交test1.txt的版本

[root@git-server test_git]# git reset --hard a6b42d8
HEAD 现在位于 a6b42d8 commite test1.txt

#已经回退到第一个版本、test2的文件是未add到暂存区
[root@git-server test_git]# git status
# 位于分支 master
# 未跟踪的文件:
#   （使用 "git add <file>..." 以包含要提交的内容）
#
#	test2.txt
提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）

```

git版本指针

![image-20200706174930054](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200706174930054.png)

#### git穿梭未来

穿梭未来有点吓人，其实还是基于git log的恢复，如快照的恢复了。

当你发现你git reset回退版本选错了ID，怎么办？别怕

`git reflog`帮你记录你每一次执行的命令

```shell
 git reflog
a6b42d8 HEAD@{0}: reset: moving to a6b42d8
5c90733 HEAD@{1}: commit: commite test2.txt
a6b42d8 HEAD@{2}: commit (initial): commite test1.txt

例子：之前回到commit test1.txt回错了现在想再次回到commit test2.txt

[root@git-server test_git]# git reset --hard 5c90733
HEAD 现在位于 5c90733 commite test2.txt

#此时工作目录存在这两个文件
[root@git-server test_git]# ll
总用量 0
-rw-r--r-- 1 root root 0 11月 16 16:12 test1.txt
-rw-r--r-- 1 root root 0 11月 16 16:21 test2.txt

#检查工作区与暂存区是否一致
[root@git-server test_git]# git status
# 位于分支 master
无文件要提交，干净的工作区

#检查本地仓库与暂存区是否一致
[root@git-server test_git]# git diff --cached

#同时检测三个区域的一致性
[root@git-server test_git]# git diff HEAD


```

我想回到某一个点，可以再次git reset --hard 版本id

#### git stash

保存当前暂存区和工作区的改动存储起来，执行完毕git stash之后，再次运行git status就会发现当前已是个干净的工作区，通过git stash list查看结果

命令整理

```shell
git stash 保存暂存区，工作区进度

git stash list 查看stash保存的列表以及id

git stash pop  恢复最新的stash进度到工作区

git stash pop stash_id  恢复指定的stash进度

git stash clear 清空所有存储的stash进度

git stash drop stash_id  删除一个存储的stash进度
```

#### git stash实际用法

`git stash`会把所有未提交的修改(已经git add 还未git commit)都保存起来，用于以后续恢复当前工作目录。 比如下面的中间状态，通过`git stash`命令推送一个新的储藏，当前的工作目录就干净了。

```shell
[root@git-server test_git]# echo 'hello1'>>test3.txt
[root@git-server test_git]# echo 'hello2'>>test4.txt

[root@git-server test_git]# git add .
[root@git-server test_git]# git status
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	新文件：    test3.txt
#	新文件：    test4.txt

[root@git-server test_git]# ls
test1.txt  test2.txt  test3.txt  test4.txt


# 如上有2个文件，已经被加入了暂存区
# 使用stash可以吧暂存区还未提交的内容，临时存储起来
[root@git-server test_git]# git stash  save 'This is my two file'
Saved working directory and index state On master: This is my two file
HEAD 现在位于 5c90733 commite test2.txt


# 发现只剩下两个文件了
[root@git-server test_git]# ls
test1.txt  test2.txt


# 找回stash文件内容
# 查看储藏室列表
[root@git-server test_git]# git stash list
stash@{0}: On master: This is my two file


# 找回储藏室的文件内容
[root@git-server test_git]# git stash pop
# 位于分支 master
# 要提交的变更：
#   （使用 "git reset HEAD <file>..." 撤出暂存区）
#
#	新文件：    test3.txt
#	新文件：    test4.txt
#
丢弃了 refs/stash@{0} (5238bdc67dab970dc4d305cff0fd1a4420ed627d)

[root@git-server test_git]# ls
test1.txt  test2.txt  test3.txt  test4.txt

```





### 10.12、Git分支



#### Git分支

在前面我们基本了解Git的使用方法，这一节我们看下GIt重要概念【分支】

在开发软件的时候，可能有多人同时开发一个软件功能或者修复BUG。

假设超哥要开发一个同性在线交友的网站，这个写代码的工作进行分配，分给两个小弟进行功能开发，一个是武沛奇分支，一个是苑昊分支，他俩自己的分支别人看不到，当他俩代码写完后，合并到master主分支上，这样既保证主代码的安全，又能协同开发，互不影响。

![image-20200707104340624](notes/image-20200707104340624.png)





#### git分支命令

```shell
1.查看分支，查看当前分支情况，在哪一个就有*符
[root@git-server test_git]# git branch
* master


此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。
当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。
如果我们要手动创建一个分支。执行 git branch (branchname) 即可。



2.创建分支
[root@git-server test_git]# git branch syh
[root@git-server test_git]# git branch
* master
  syh


现在我们可以看到，有了一个新分支 onlyu。
接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。  


3.git分支练习
[root@git-server test_git]# git commit -m 'commit to master_branch  on master'
[master 2a3cb84] commit to master_branch  on master
 3 files changed, 3 insertions(+)		#master分支创建了这三个文件
 create mode 100644 master_branch
 create mode 100644 test3.txt
 create mode 100644 test4.txt

[root@git-server test_git]# ls
master_branch  test1.txt  test2.txt  test3.txt  test4.txt


# 此时切换分支，Git会还原工作区的内容，到创建分支时的状态
[root@git-server test_git]# git checkout syh
切换到分支 'syh'
[root@git-server test_git]# 
[root@git-server test_git]# ls					#和之前相比少了3个文件
test1.txt  test2.txt

# 切换回master，数据又回来了
[root@git-server test_git]# git checkout master
切换到分支 'master'
[root@git-server test_git]# 
[root@git-server test_git]# ls
master_branch  test1.txt  test2.txt  test3.txt  test4.txt


4.我们也可以直接创建且切换分支
[root@git-server test_git]# git checkout -b cc
切换到一个新分支 'cc'
[root@git-server test_git]# git branch
* cc
  master
  syh

[root@git-server test_git]# echo "我是新的cc分支">cc_branch
[root@git-server test_git]# git add .
[root@git-server test_git]# git commit -m 'commit to cc_branch on cc_branch'
[cc 903a93d] commit to cc_branch on cc_branch
 1 file changed, 1 insertion(+)
 create mode 100644 cc_branch

[root@git-server test_git]# ls
cc_branch  master_branch  test1.txt  test2.txt  test3.txt  test4.txt


# 如缩减，当我们回退到主分支的时候，新创建的文件已然消失了
# 使用分支，实现了在不同的分支环境下工作，且可以来回切换
[root@git-server test_git]# git checkout master
切换到分支 'master'
[root@git-server test_git]# ls
master_branch  test1.txt  test2.txt  test3.txt  test4.txt

[root@git-server test_git]# git checkout syh
切换到分支 'syh'
[root@git-server test_git]# ls
test1.txt  test2.txt


5.删除分支，删除分支后，随之分支管理的文件内容也被删了

#注意这里的cc分支是暂未合并的
[root@git-server test_git]# git branch -d cc
error: 分支 'cc' 没有完全合并。

如果您确认要删除它，执行 'git branch -D cc'。
[root@git-server test_git]# git branch -D cc
已删除分支 cc（曾为 903a93d）。
[root@git-server test_git]# git branch
* master
  syh



6.一旦分支有了独立的内容，你最终目的是，将分支独立开发的内容合并到主干分支。
# 主分支下内容
[root@git-server mygit2]# git branch
* master
[root@git-server mygit2]# ls
maset



# syh分支下的内容
[root@git-server mygit2]# git branch
  master
* syh
[root@git-server mygit2]# ls
maset  syh



# 合并yuchao分支的文件内容到主干master
# 回退到master分支，然后执行命令
[root@git-server mygit2]# git checkout master
切换到分支 'master'
[root@git-server mygit2]# ls
maset
[root@git-server mygit2]# git merge syh
更新 a258582..0cb44c9
Fast-forward
 syh | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 syh

 # 此时发现已经在master主干分支，新增了一个文件
[root@git-server mygit2]# git branch
* master
  syh
[root@git-server mygit2]# ls
maset  syh


合并完之后，就可以删除该分支了，下次需要用分支开发，可以再次创建即可
[root@git-server mygit2]# git branch -d syh
已删除分支 syh（曾为 0cb44c9）。
[root@git-server mygit2]# 
[root@git-server mygit2]# 
[root@git-server mygit2]# git branch
* master
```

#### git合并分支冲突

合并不仅仅是简单的对文件添加、移除，git可以合并且修改。

我们准备数据

```shell
1.准备开始进行开发了，新建一个分支
[root@git-server mygit2]# git branch chao
[root@git-server mygit2]# git checkout chao
切换到分支 'chao'

[root@git-server mygit2]# ls
maset  syh

[root@git-server mygit2]# echo 'i am chao'>chao.php


2.将创建的文件内容，提交到chaoge分支
[root@git-server mygit2]# git add .
[root@git-server mygit2]# git commit -m 'commit chao.php on chaoge_branch'
[chao 1fdcbf0] commit chao.php on chaoge_branch
 1 file changed, 1 insertion(+)
 create mode 100644 chao.php
[root@git-server mygit2]# ls
chao.php  maset  syh


 3.此时我们切换回master分支，chao.php文件应该是不存在的
[root@git-server mygit2]# git checkout master
切换到分支 'master'
[root@git-server mygit2]# ls
maset  syh


4.我们在master分支下，也创建名为chao.php的文件，且写入内容
[root@git-server mygit2]# git branch
  chao
* master
[root@git-server mygit2]# echo '<?php我是冲突 ?>'>chao.php

# 提交到本地仓库
[root@git-server mygit2]# git add .
[root@git-server mygit2]# git commit -m 'commit to chao.php on master'
[master d82d956] commit to chao.php on master
 1 file changed, 1 insertion(+)
 create mode 100644 chao.php


 5.此时你会发现，chaoge.php文件在master分支和chaoge分支，都有自己的代码内容，是不是？
 如果此时你合并分支，会发现如下问题
[root@git-server mygit2]# git checkout master
已经位于 'master'
[root@git-server mygit2]# 
[root@git-server mygit2]# git merge chao
自动合并 chao.php
冲突（添加/添加）：合并冲突于 chao.php
自动合并失败，修正冲突然后提交修正的结果。
发现了git给与的提示是，自动合并失败了，需要你自己手动解决冲突，然后提交结果

6.查看文件内容，文件被git自动修改了
第二行发生了文件内容冲突
master主分支上内容是 echo "<?php我是冲突 ?>"
chaoge分支合并过来的内容是 echo "i am chao"
此时根据你自己的需求，决定如何修改代码文件，再次提交即可
[root@git-server mygit2]# cat -n chao.php
     1	<<<<<<< HEAD
     2	<?php我是冲突 ?>
     3	=======
     4	i am chao
     5	>>>>>>> chao


7.自己决定对代码修改
[root@git-server mygit2]# git diff
diff --cc chao.php
index 4b645c7,b741196..0000000
--- a/chao.php
+++ b/chao.php
@@@ -1,1 -1,1 +1,5 @@@
++<<<<<<< HEAD
 +<?php我是冲突 ?>
++=======
+ i am chao
++>>>>>>> chao


# 手动修改代码为确定版本，比如两个代码我都要保留
[root@git-server mygit2]# cat chao.php
<?php

echo 'hello i come'

?>


[root@git-server mygit2]# git add .
[root@git-server mygit2]# git commit -m 'modify chao.php on master'
[master 858eba2] modify chao.php on master
[root@git-server mygit2]# 
[root@git-server mygit2]# git status
# 位于分支 master
无文件要提交，干净的工作区

[root@git-server mygit2]# ls
chao.php  maset  syh
[root@git-server mygit2]# cat chao.php 
<?php

echo 'hello i come'

?>


现在我们就解决了合并中的冲突，然后提交了结果
```



### 10.13、Git标签

#### Git标签

#### git标签有什么用

Git仓库内的数据发生变化时，我们经常会打上一个类似于软件版本的标签tag，这样通过标签就可以把版本库中的某个版本给记录下来，便于以后我们可以将特定的数据取出来。

标签就是版本库的一个快照。

#### 为啥用git标签

git不是已经有commit了吗，可以附加提交信息，为什么还要tag呢？

开发小王：请吧上周一发布的版本打包发布，commit_id是3f6cccf0708525b58fe191c80325b73a54adee99

运维小于：你这什么乱七八糟的数字，，，太难找了，请你换个方法

开发小王换了个方式：请吧上周一发布的版本打包，版本号是v1.2，按照tag v1.2查找commit 记录就行了！

所以tag就是一个容易记住的名字，和某个commit记录绑定在一起。

#### git标签使用

对当前提交的代码创建标签，-a标签名称，-m标签描述。

```shell
1.# 对当前最新的commit记录进行标签
[root@git-server mygit2]# git tag -a 'v1.0' -m "修复user-login"


2.# 直接输入，则查看当前标签
[root@git-server mygit2]# git tag
v1.0


3.# 指定commitID创建标签，选中commit id 前7位就够了
[root@git-server mygit2]# git tag -a v1.3 858eba2 -m 'modify chao.php from master'


4.# 查看标签列表
[root@git-server mygit2]# git tag
v1.0
v1.1
v1.3


5.# 查看标签里有什么git show
[root@git-server mygit2]# git show v1.1
tag v1.1
Tagger: syh <17688702764@163.com>
Date:   Mon Nov 16 19:49:00 2020 +0800

creaste haha.txt

commit fe5fea1cd69161c5fa3e20a203643497513c74a4
Author: syh <17688702764@163.com>
Date:   Mon Nov 16 19:46:15 2020 +0800

    commit haha.txt from master

diff --git a/haha.txt b/haha.txt
new file mode 100644
index 0000000..e69de29



6.# 通过git log查看tag
# --graph：显示ASCII图形表示的分支合并历史
# --pretty＝：使用其他格式显示历史提交信息
# -abbrev-commit：仅显示SHA-1的前几个字符，而非所有的40个字符 
# --decorate：突出分支名高亮显示
[root@git-server mygit2]# git log --oneline --decorate --graph
* fe5fea1 (HEAD, tag: v1.1, master) commit haha.txt from master
*   858eba2 (tag: v1.3, tag: v1.0) modify chao.php on master
|\  
| * 1fdcbf0 (chao) commit chao.php on chaoge_branch
* | d82d956 commit to chao.php on master
|/  
* 0cb44c9 commit to syh on branch from syh
* a258582 commit to master on master


7.删除tag
[root@git-server mygit2]# git tag -d v1.3
已删除 tag 'v1.3'（曾为 a9b6f9d）
[root@git-server mygit2]# git tag
v1.0
v1.1

```

![img](notes/1.png)





### 10.14、git小结命令总结



| 常用命令                                 | 作用                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| git init                                 | 初始化工作目录                                               |
| git status                               | 查看暂存区状态                                               |
| git add                                  | 将文件从工作目录添加到暂存区、通常使用git add .表示把工作目录的内容加到暂存区 |
| git mv                                   | 用于改变工作目录中文件的名字、且提交到暂存区、并将存在暂存区内的旧名文件删除 |
| git commit -m                            | 将文件从暂存区添加到本地仓库                                 |
| git log                                  | 查看详细commit的记录                                         |
| git log --oneline                        | 查看简单的commit记录、包括id号、备注信息                     |
| git diff                                 | 比较工作目录与暂存区的内容差异                               |
| git  diff -cached                        | 比较暂存区与本地仓库的内容差异                               |
| git diff HEAD                            | 比较三个区域的内容                                           |
| git reset --hard +id                     | 指定ID号进行版本回退                                         |
| git branch                               | 查看分支情况、带*的表示处于当前处于这个分区                  |
| git branch  分区名                       | 创建分支                                                     |
| git checkout 分区名                      | 切换分区                                                     |
| git branch -d 分区名                     | 删除合并的分支                                               |
| git branch -D 分区名                     | 删除未合并的分支                                             |
| git merge chao                           | 在master分支内将其他分支与master分支合并                     |
| git tag -a “版本号” -m ‘备注信息’        | 对当前最新的commit记录进行标签、并附加备注                   |
| git tag                                  | 查看当前分区有哪些                                           |
| git tag -a 版本号  858eba2 -m “备注信息” | 指定id号来生成版本号、并附加备注                             |
| git show 标签名                          | 显示具体版本号的内容                                         |
| git tag -d 标签名                        | 删除标签                                                     |
| git log --oneline --decorate --graph     | 查看日志信息、--oneline :表示显示简单的日志信息（包括ID以及备注信息）--decorate:表示突出分支字体高亮   --graph：表示显示ASCII图形表示的分支合并历史 |
| git reflog                               | 记录每一次执行的命令                                         |





### 10.15、gitee远程仓库介绍



#### gitee远程仓库

git是一个分布式版本控制系统，同一个git仓库可以分布在不同的机器上，但是开发团队必须保证在同一个网络中，且必须有一个项目的原始版本，通常的办法就是让一台电脑充当服务器的角色，每天24小时开机，其他每个人都可以在这台"服务器"仓库里克隆一份代码到自己的电脑上。

并且也可以把各自的代码提交到代码仓库里，也能从代码仓库拉取别人的提交。

这样的代码仓库服务器，我们可以自由的搭建，也可以选择使用免费的托管平台。

Git代码托管平台，首先推荐的是Github，世界范围内的开发者都在使用Github托管代码，可以找到大量优秀的开源项目，缺点就是访问可能会卡一点。

其次选择的就是Gitee，国内的代码托管平台，以及自建Gitlab服务器。 ![image-20200707155533602](notes/image-20200707155533602.png)

Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务。

官网地址

```shell
https://gitee.com/
注册后登录即可
```

```
注册账号：17688702764
密码：s17688702764
```

![image-20201117151748047](notes/image-20201117151748047.png)



### 10.16、gitee的基本使用



#### 创建空仓库

点击右上角的➕，新建仓库

![image-20201117152133093](notes/image-20201117152133093.png)

创建完毕空仓库后，页面出现如下仓库使用方式，我们可以选择HTTPS和SSH形式下载代码的方式，根据以下方式操作即可

![image-20201117152212136](notes/image-20201117152212136.png)



到这里，我们仓库就已经创建好了，接着就是要将本地客户端和服务端连接起来，存在于两种情况

![image-20201117153550063](notes/image-20201117153550063.png)

- 本地已经有一个git仓库了
- 本地还没有git仓库





#### 配置客户端连接gitee仓库(HTTPS)

#### 推送本地仓库到远程

HTTPS协议也就指的是使用账号密码连接

1.git全局设置

```shell
git config --global user.name "su_yh666"
git config --global user.email "937921303@qq.com"
```

2.创建git仓库

```shell
mkdir git_test2
cd git_test2
git init
touch README.md
git add README.md
git commit -m "first commit"
# 为本地仓库gitee_learn添加远程仓库别名origin，地址是如下链接
git remote add origin https://gitee.com/yuco/gitee_learn.git
git push -u origin master
# 输入正确gitee账号密码之后即可正确把代码推送到远程仓库
[root@git-server git_test2]# git push -u origin master
Username for 'https://gitee.com': 17688702764	^H
Password for 'https://17688702764      @gitee.com': 
fatal: Authentication failed for 'https://gitee.com/su-yh666/git_test2.git/'
[root@git-server git_test2]# git push -u origin master
Username for 'https://gitee.com': 17688702764
Password for 'https://17688702764@gitee.com': 
Counting objects: 3, done.
Writing objects: 100% (3/3), 208 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: Powered by GITEE.COM [GNK-5.0]
To https://gitee.com/su-yh666/git_test2.git
 * [new branch]      master -> master
分支 master 设置为跟踪来自 origin 的远程分支 master。

```

3.此时可以访问远程代码仓库了，发现本地创建的文件已经推送上去

```shell
https://gitee.com/yuco/gitee_learn
```

![image-20201117155932818](notes/image-20201117155932818.png)



#### 配置客户端连接gitee仓库(SSH)

#### 推送本地仓库到远程

SSH协议也就指的是使用公私钥比对验证

1.git全局设置

```shell
git config --global user.name "su_yh666"
git config --global user.email "937921303@qq.com"
```

2.创建git仓库

```shell
mkdir git_test
cd git_test
git init
touch test
git add test
git commit -m "first commit"
# 为本地仓库gitee_learn添加远程仓库别名origin，地址是如下链接
git remote add origin git@gitee.com:su-yh666/git_test.git
git push -u origin masterr
# 输入yes,此时会提示权限不足，说明客户端本地无法信任远程的gitee
[root@git-server git_test]# git push -u origin master

Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.


#此时就要在客户端本地生成公私钥
[root@git-server git_test]# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:rmagDx4Iujo2KGEw+ebHxg/kkNXdppUvaw3MeRCtaCY root@git-server
The key's randomart image is:
+---[RSA 2048]----+
|          ..     |
|     . . . o.    |
| .  . . ..*.     |
|+  o  E +*.+     |
|ooo .  +S * o    |
|+oo+.  .   *     |
|=+o+o.  . o .    |
|+=oo=.o. .       |
|*.o+.+o          |


[root@git-server git_test]# ls ~/.ssh
id_rsa  id_rsa.pub  known_hosts

#将公钥的信息复制到gitee上的ssh key
[root@git-server git_test]# cat ~/.ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFUOB2D6XxwHfucpuOpBAp65rKavJfYMKH3CDpeYJW9dYOeXFKsbdGUn2FIDYetuHvLx81nEZbhthpxLQcDu9OTKnIz5UBQjqL5cRbIVN+yzVsfr5tDwGcBI/6vWjI990ZF0OOiUYog0yFgTB+TFVescUY1Pzm+VpipCAlFHVEiHtGXdsSOoal5a0NqeS2I3Hv+Di9XSBmQneNucZKOqzWlDGKZopDf50G2dPvSmTqcdd++qcKgwb0HtKeKUd0DM2a+GNuDo8GzXUh2dJiGusrhokKPCeKiKdzTp3FxpzMaynLDaIGK4GtqNofj7SqIwGEETYGd0fUDbPf/bg/cWph root@git-server

```

web操作--添加公钥

![image-20201117160842219](notes/image-20201117160842219.png)

```shell
#此时再次进行推送、已经成功推送
[root@git-server git_test]# git push -u origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 208 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: Powered by GITEE.COM [GNK-5.0]
To git@gitee.com:su-yh666/git_test.git
 * [new branch]      master -> master
分支 master 设置为跟踪来自 origin 的远程分支 master。

```

3.此时可以访问远程代码仓库了，发现本地创建的文件已经推送上去

![image-20201117161151095](notes/image-20201117161151095.png)

![image-20201117161124160](notes/image-20201117161124160.png)



#### 克隆远程仓库到本地

如果我们在任意一个其他的客户端想要获取仓库的代码，我们只需要克隆一份远程仓库代码即可，在克隆之前，仍然要配置好客户端和gitee的认证关系，或是使用账号密码下载即可。

此时可以再准备一台linux机器，模拟另一个客户端

```shell
# 以配置好了ssh-key为准，直接使用ssh协议的下载
[root@git-client2 ~]# git clone git@gitee.com:su-yh666/git_test.git
正克隆到 'git_test'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
接收对象中: 100% (3/3), done.



# 克隆好了之后，我们本地已然有了代码
[root@git-client2 ~]# ls git_test/
README.md


# 此时该用户也可以继续开发新功能，然后推送到远程代码仓库，供他人下载
[root@git-client2 git_test]# echo '我是开发了新功能'>index.html

[root@git-client2 git_test]# git add .

[root@git-client2 git_test]# git commit -m 'first commit'
[master 8befedd] first commit
 1 file changed, 1 insertion(+)
 create mode 100644 index.html

[root@git-client2 git_test]# git status
# 位于分支 master
# 您的分支领先 'origin/master' 共 1 个提交。
#   （使用 "git push" 来发布您的本地提交）
#
无文件要提交，干净的工作区

[root@git-client2 git_test]# git push -u origin master
Counting objects: 4, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: Powered by GITEE.COM [GNK-5.0]
To git@gitee.com:su-yh666/git_test.git
   dacf431..8befedd  master -> master
分支 master 设置为跟踪来自 origin 的远程分支 master。
[root@git-client2 git_test]# ls
index.html  README.md



# 此时远程仓库又有了新的代码
https://gitee.com/su-yh666/git_test
```



![image-20201117172152400](notes/image-20201117172152400.png)



### 10.16、git fetch的使用

#### git fetch使用

上述案例，我们在另一个客户端推送了新的代码，此时代码仓库中是最新的，但是其他客户端代码是不是已经旧了，我们得更新代码对把。需要把代码仓库里的更新取回本地，这就得用到git fetch命令。

`git fetch`作用是取回所有分支(branch)的更新，如果只想更新特定的分支代码，可以指定分支名，比如取回远程origin仓库的master分支代码，即可这么写

```shell
git fetch origin master
```

案例

```shell
[root@git-server git_test]# git fetch
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 2 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (2/2), done.
来自 gitee.com:su-yh666/git_test
   8befedd..89840af  master     -> origin/master

```

取回来的更新，要在本地主机上采用`远程主机名/分支名`的形式读取，比如origin主机上的master，那就是origin/master来读取。

```shell
可以采用git branch -r选项，查看远程分支，-a查看所有分支
[root@git-server git_test]# git branch -r
  origin/master
[root@git-server git_test]# git branch -a
* master
  remotes/origin/master
  remotes/origin/master

```

取回远程主机的更新,有几种方式，

1是创建新分支、用于合并获取；

2是在本地客户端直接通过git pull获取；

```shell
方法1：
[root@git-server git_test]# git checkout -b remote-master origin/master
分支 remote-master 设置为跟踪来自 origin 的远程分支 master。


# 此时查看的是远程分支上的数据
[root@git-server git_test]# git branch
  master
* remote-master
  remotes/origin/master
[root@git-server git_test]# ls
66.txt  index.html  README.md

```

使用`git merge命令`合并远程分支的代码到master主干

```shell
# 回到master，合并分支
# 切换分支时，git已经提示你，master分支的代码已经落后了，可以更新了
[root@git-server git_test]# git checkout master
切换到分支 'master'
您的分支落后 'origin/master' 共 1 个提交，并且可以快进。
  （使用 "git pull" 来更新您的本地分支）

#这里可以使用pull获取远程仓库同步、也可以合并分区remote-master到主干

#通过git pull 同步远程仓库数据
[root@git-server git_test]# git pull 
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 2 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (2/2), done.
来自 gitee.com:su-yh666/git_test
   89840af..b4d097a  master     -> origin/master
更新 89840af..b4d097a
Fast-forward
 77 | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 77
[root@git-server git_test]# ls
66.txt  77  index.html  README.md


 #将分支代码合并到主干，结束操作
[root@git-server git_test]# git merge remote-master
更新 8befedd..89840af
Fast-forward
 66.txt | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 66.txt
[root@git-server git_test]# git branch
* master
  remote-master
  remotes/origin/master
[root@git-server git_test]# ls
66.txt  index.html  README.md

```



### 10.17、Gitlab介绍

### Gitlab

![image-20200708091136140](notes/image-20200708091136140.png)

![image-20200708091154862](notes/image-20200708091154862.png)

![image-20200708091226949](notes/image-20200708091226949.png)

### Gitlab介绍

**我们了解了git是以个人为中心，但是人人都得数据交互呀。。python程序员每天都忙着进行py交易**

交互数据的方式

- 使用github或者码云等公有代码仓库，托管代码的地方，谁都可以看
- 公司内部使用gitlab私有仓库

github和gitlab的区别

- github国外公共仓库不安全，国内的码云代码仓库，可能会暴露自己公司代码机密，等着被开除吧。。
- 自建gitlab私有代码仓库，更加安全
- 从代码私有性方面来看，公司不希望员工随意获取全部代码，使用Gitlab无疑是最好的选择
- 若是开源项目，Github还是代码托管的首选平台。

![image-20200708091356915](notes/image-20200708091356915.png)

Gitlab是一个开源分布式的版本控制系统，由Ruby语言开发，Gitlab主要实现的功能、管理项目源代码、对源代码进行版本控制，以及源代码的复用和查找。

Gitlab优势和应用场景：

- 开源免费，搭建简单，维护成本低，适合中小型公司。
- 权限管理，实现代码对部分人可见，确保醒目安全性。
- 离线同步，保证我们不需要依赖于网络环境进行代码提交（代码本地仓库管理然后推到远程仓库）





### 10.18、gItlab的安装

#### Gitlab安装配置

环境准备

```shell
操作系统centos7
内存：2G及以上
磁盘：50G
安全：关闭防火墙，selinux
```

1.安装GItlab所需的依赖包

```shell
yum install curl policycoreutils-python openssh-server postfix wget -y
```

2.安装gitlab，可以在线装，也可以安装本地准备好的rpm包，

```shell
#通过yum安装
[root@lb02 opt]# yum localinstall gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm -y

#通过清华源下载
https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/

[root@git-server usr]# cd /opt 
[root@git-server opt]# wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm
[root@git-server opt]# ls
gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm


#安装
[root@git-server opt]# rpm -ivh gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm 
警告：gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:gitlab-ce-12.0.3-ce.0.el7        ################################# [100%]
It looks like GitLab has not been configured yet; skipping the upgrade script.

       *.                  *.
      ***                 ***
     *****               *****
    .******             *******
    ********            ********
   ,,,,,,,,,***********,,,,,,,,,
  ,,,,,,,,,,,*********,,,,,,,,,,,
  .,,,,,,,,,,,*******,,,,,,,,,,,,
      ,,,,,,,,,*****,,,,,,,,,.
         ,,,,,,,****,,,,,,
            .,,,***,,,,
                ,*,.
  


     _______ __  __          __
    / ____(_) /_/ /   ____ _/ /_
   / / __/ / __/ /   / __ `/ __ \
  / /_/ / / /_/ /___/ /_/ / /_/ /
  \____/_/\__/_____/\__,_/_.___/
  

Thank you for installing GitLab!
GitLab was unable to detect a valid hostname for your instance.
Please configure a URL for your GitLab instance by setting `external_url`
configuration in /etc/gitlab/gitlab.rb file.
Then, you can start your GitLab instance by running the following command:
  sudo gitlab-ctl reconfigure

For a comprehensive list of configuration options please see the Omnibus GitLab readme
https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md

#出现这个页面说明安装成功
```

#### gitlab的邮箱配置

3.配置gitlab服务，修改域名和邮箱

```shell
# 安装好后，默认提示Please configure a URL for your GitLab instance by setting `external_url`
# configuration in /etc/gitlab/gitlab.rb file.
需要修改配置文件，换成你自己的服务器地址就好
vim /etc/gitlab/gitlab.rb
external_url 'http://192.168.37.134'


配置邮箱，打开注释，修改配置，注意别改错了，否则将无法收到邮件
### Email Settings
gitlab_rails['gitlab_email_enabled'] = true
gitlab_rails['gitlab_email_from'] = '17688702764@163.com'
gitlab_rails['gitlab_email_display_name'] = 'su_yh666'


# email server settings
gitlab_rails['smtp_enable'] = true
gitlab_rails['smtp_address'] = "smtp.163.com"
gitlab_rails['smtp_port'] = 465
gitlab_rails['smtp_user_name'] = "17688702764@163.com"
gitlab_rails['smtp_password'] = "LQMXJWOSJQYVPFNY"		163的授权码
gitlab_rails['smtp_domain'] = "smtp.163.com"
gitlab_rails['smtp_authentication'] = "login"
gitlab_rails['smtp_enable_starttls_auto'] = true
gitlab_rails['smtp_tls'] = true


#修改完后、使用如下命令进行重读配置文件
[root@git-server opt]# gitlab-ctl reconfigure

Running handlers:
Running handlers complete
Chef Client finished, 513/1343 resources updated in 02 minutes 19 seconds
gitlab Reconfigured!


```

可以进入gitlab命令行，测试邮件收发是否正常

```shell
[root@git-server opt]# gitlab-rails console
-------------------------------------------------------------------------------------
 GitLab:       12.0.3 (08a51a9db93)
 GitLab Shell: 9.3.0
 PostgreSQL:   10.7
-------------------------------------------------------------------------------------
Loading production environment (Rails 5.1.7)
irb(main):001:0> Notify.test_email('937921303@qq.com','我是标题','我是正文内容').deliver_now
Notify#test_email: processed outbound mail in 161.2ms
Sent mail to 937921303@qq.com (824.2ms)
Date: Tue, 17 Nov 2020 21:00:30 +0800
From: su_yh666 <17688702764@163.com>
Reply-To: su_yh666 <noreply@192.168.37.134>
To: 937921303@qq.com
Message-ID: <5fb3c96ea56d5_158d3ff9cf8cf9c091771@git-server.mail>
Subject: =?UTF-8?Q?=E6=88=91=E6=98=AF=E6=A0=87=E9=A2=98?=
Mime-Version: 1.0
Content-Type: text/html;
 charset=UTF-8
Content-Transfer-Encoding: 7bit
Auto-Submitted: auto-generated
X-Auto-Response-Suppress: All

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>&#25105;&#26159;&#27491;&#25991;&#20869;&#23481;</p></body></html>

=> #<Mail::Message:70341797347540, Multipart: false, Headers: <Date: Tue, 17 Nov 2020 21:00:30 +0800>, <From: su_yh666 <17688702764@163.com>>, <Reply-To: su_yh666 <noreply@192.168.37.134>>, <To: 937921303@qq.com>, <Message-ID: <5fb3c96ea56d5_158d3ff9cf8cf9c091771@git-server.mail>>, <Subject: 我是标题>, <Mime-Version: 1.0>, <Content-Type: text/html; charset=UTF-8>, <Content-Transfer-Encoding: 7bit>, <Auto-Submitted: auto-generated>, <X-Auto-Response-Suppress: All>>
```

测试成功

![image-20201117210205971](notes/image-20201117210205971.png)



4.初始化gitlab

```shell
# 注意，当修改了gitlab配置文件，就得reconfigure
 gitlab-ctl reconfigure

# 启停
gitlab-ctl start |restart |status |stop

# 初始化之后，gitlab组件都已经启动了
 gitlab-ctl status
```

#### **Gitlab服务构成**

```shell
GitLab 由主要由以下服务构成，他们共同承担了 Gitlab 的运作需要
Nginx:静态 web 服务器。
gitlab-shell:用于处理 Git 命令和修改 authorized keys 列表。 
gitlab-workhorse: 轻量级的反向代理服务器。 logrotate:日志文件管理工具。
postgresql:数据库。
redis:缓存数据库。
sidekiq:用于在后台执行队列任务(异步执行)。
unicorn:An HTTP server for Rack applications，GitLab Rails 应用是托管在这个
```

#### gitlab工作流程



![image-20201117211220583](notes/image-20201117211220583.png)

```
GitLab Shell
GitLab Shell 有两个作用：为 GitLab 处理 Git 命令、修改 authorized keys 列表。
当通过 SSH 访问 GitLab Server 时，GitLab Shell 会：
限制执行预定义好的 Git 命令（git push, git pull, git annex）
调用 GitLab Rails API 检查权限
执行 pre-receive 钩子（在 GitLab 企业版中叫做 Git 钩子）
执行你请求的动作 处理 GitLab 的 post-receive 动作
处理自定义的 post-receive 动作
当通过 http(s)访问 GitLab Server 时，工作流程取决于你是从 Git 仓库拉取(pull)代
码还是向 git 仓库推送(push)代码。
如果你是从 Git 仓库拉取(pull)代码，GitLab Rails 应用会全权负责处理用户鉴权和
执行 Git 命令的工作；
如果你是向 Git 仓库推送(push)代码，GitLab Rails 应用既不会进行用户鉴权也不会
老男孩IT教育
执行 Git 命令，它会把以下工作交由 GitLab Shell 进行处理：
调用 GitLab Rails API 检查权限
执行 pre-receive 钩子（在 GitLab 企业版中叫做 Git 钩子）
执行你请求的动作
处理 GitLab 的 post-receive 动作
处理自定义的 post-receive 动作
```

6.首次访问gitlab

```
http://192.168.37.134/

首次需要输入2次密码
suyonghong666
suyonghong666

然后可以登录，默认账号密码
root
suyonghong666
```

![image-20201117210905260](notes/image-20201117210905260.png)

登录进入首页

![image-20201117211052082](notes/image-20201117211052082.png)

#### gitlab管理命令

7.gitlab管理命令

```shell
#启动所有gitlab组件
gitlab-ctl start			

#停止所有gitlab组件
gitlab-ctl stop

#停止postgresql组件
gitlab-ctl stop postgresql

#重启所有gitlab组件
gitlab-ctl restart 

#检查所有gitlab组件状态
gitlab-ctl status

# 如果更改了主配置文件 [gitlab.rb 文件],使配置文件生效 但是会初始化除了gitlab.rb 之外的所有文件
gitlab-ctl reconfigure

# 查看日志
gitlab-ctl tail

#检查 redis 的日志
gitlab-ctl tail redis
```

#### gitlab主要目录

```shell
/var/opt/gitlab/git-data/repositories/ ：库默认存储目录
/opt/gitlab  ：应用代码和相应的依赖程序
/var/opt/gitlab/ ： gitlab-ctl reconfigure生成的数据和配置
/etc/gitlab ：配置文件目录
/var/log/gitlab：此目录下存放了gitlab各个组件产生的日志
/var/opt/gitlab/backups ：备份文件生成的目录
```



## gitlab汉化配置

```shell
汉化地址https://gitlab.com/xhang/gitlab，可以进行下载

解压缩下载的汉化包
[root@git-server opt]# tar -zxf gitlab-12-3-stable-zh.tar.gz 


# 确保汉化包，和gitlab软件包版一致
[root@git-server opt]# ls
gitlab  gitlab-12-3-stable-zh  gitlab-12-3-stable-zh.tar.gz  gitlab-ce-12.0.3-ce.0.el7.x86_64.rpm


# 停止gitlab
gitlab-ctl stop

# 中文覆盖英文，使用原生cp命令，直接进行覆盖，出现的错误直接忽略
\cp -rf gitlab-12-3-stable-zh/* /opt/gitlab/embedded/service/gitlab-rails/

# 再次启动
gitlab-ctl start

# 稍微等待一会，再次访问gitlab，若是出现502，再等会
http://192.168.37.134/
```





### 10.19、gitlab基本使用



#### 关闭注册功能

我们GItlab是企业级内部私有代码仓库，所有用户都英国由管理员创建，而非外部注册，我们可以关闭其功能，保障平台安全。



![image-20201117211936160](notes/image-20201117211936160.png)



![image-20201118111857611](notes/image-20201118111857611.png)

![image-20201118111951109](notes/image-20201118111951109.png)

2.保存后，退出登录，发现已经没有注册选项了。

![image-20201118112120917](notes/image-20201118112120917.png)





#### Gitlab仓库管理

#### 用户、组、项目联系

![image-20200708135625100](notes/image-20200708135625100.png)

GitLab 是通过组（group）的概念来统一管理仓库（project）和用户（user），通过创建组，在组下再创建仓库，再将用户加入到组，从而实现用户与仓库的权限管理。

#### 创建组



![image-20201118113004117](notes/image-20201118113004117.png)



![image-20201118113110182](notes/image-20201118113110182.png)



注：visibility Level：选择谁可以访问该组：我们默认选择 private 即可，

Private:只有授权的用户才可以看到

Internal：只要是登录 gitlab 的用户就可以看到

Public：只要可以访问 gitlab web 页面的人就可以看到

点击页面最下的 create group 按钮，完成组的创建，进入组管理页面

![image-20201118113235583](notes/image-20201118113235583.png)

此时我们可以在组内添加用户

#### 添加用户

![image-20201118113431788](notes/image-20201118113431788.png)



![image-20201118113706097](notes/image-20201118113706097.png)

Can create group ：取消勾选、普通用户不能创建组

Regualer：勾选，普通用户只能访问组内的仓库

Admin：管理员用户可以管理所有的组、用户、仓库

External：外部用户、只能访问pubilck的仓库

创建完用户、普通用户会收到一封邮件

![image-20201118114520655](notes/image-20201118114520655.png)



#### 设置用户密码

![image-20201118114051810](notes/image-20201118114051810.png)

右上角Edit可设置密码

![image-20201118114151928](notes/image-20201118114151928.png)

在此页面可以初始化用户密码、也可以修改用户注册信息

![image-20201118114541472](notes/image-20201118114541472.png)

修改完密码后、普通用户会收到一封邮件告知

#### 用户授权

用户创建完成后，我们就需要对用户进行授权，从而使用户可以管理仓库，有两种方式，

一是将用户加入到组，这样用户可以管理组内的仓库，二是直接授权用户管理仓库。通常我

们采用的方式是将用户加入相应的组，并赋予不同的角色。GitLab 中用户的角色是系统定

义好的，不能更改。这一点可能不符合我们正常的思维习惯。下面我们将刚创建的 dev 用户老男孩IT教育

添加到我们的 operations组，将赋予 developer 权限，

![image-20201118114951818](notes/image-20201118114951818.png)



![image-20201118114924337](notes/image-20201118114924337.png)

注：关于每一种角色对应的权限，可参见官方文档相关内容：

https://docs.gitlab.com/ee/user/permissions.html



组员添加后、此时组员邮箱收到一个告知

![image-20201118115145221](notes/image-20201118115145221.png)



#### 创建仓库

在gitlab中，你可以创建project用来存储你的程序代码、作为一个问题跟踪器，用于代码协作，用于持续集成中的构建、测试和部署等。

在管理员区域点击New project按钮，或者点击导航栏的＋。



![image-20201118115629135](notes/image-20201118115629135.png)



![image-20201118120527546](notes/image-20201118120527546.png)

![image-20201118120653909](notes/image-20201118120653909.png)

此时我们切换普通用户、即可看到仓库

当普通用户第一次登录还要再次修改密码

![image-20201118120943185](notes/image-20201118120943185.png)



#### 配置SSH KEY

前面我们已经在GitLab建立了仓库，并且授权用户可以使用仓库，我们所有的操作都是在Web界面进行的，接着我们就要配置客户端来连接代码仓库了。

我们的仓库是私有的，只有授权的用户才可以访问到该仓库，那么只要将客户端的用户 与我们GitLab的用户绑定，客户端即可访问到GitLab上的仓库，我们建议使用SSH方式实 现客户端与 Gitlab 用户的绑定，具体配置如下。

```shell
1.选择登陆一个客户端机器，生成ssh密钥对，注意，若是已经有了，可以直接复制，不需要再生成，否则会覆盖原有的密钥对
ssh-keygen -t rsa


2.和码云的操作一样，添加本地的公钥信息，发给gitlab，我们用root用户登录gitlab
cat ~/.ssh/id_rsa.pub  # 复制结果，粘贴到gitlab的密钥输入框里即可

[root@git-server git_test]# cat ~/.ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFUOB2D6XxwHfucpuOpBAp65rKavJfYMKH3CDpeYJW9dYOeXFKsbdGUn2FIDYetuHvLx81nEZbhthpxLQcDu9OTKnIz5UBQjqL5cRbIVN+yzVsfr5tDwGcBI/6vWjI990ZF0OOiUYog0yFgTB+TFVescUY1Pzm+VpipCAlFHVEiHtGXdsSOoal5a0NqeS2I3Hv+Di9XSBmQneNucZKOqzWlDGKZopDf50G2dPvSmTqcdd++qcKgwb0HtKeKUd0DM2a+GNuDo8GzXUh2dJiGusrhokKPCeKiKdzTp3FxpzMaynLDaIGK4GtqNofj7SqIwGEETYGd0fUDbPf/bg/cWph root@git-server
```

![image-20201118121911454](notes/image-20201118121911454.png)



![image-20201118121931383](notes/image-20201118121931383.png)

此处只能添加公钥，如果添加私钥系统将报错，此外一个公钥在整个 GitLab 系统中只能添加一次，但是一个 GitLab 用户可以添加多个公钥。

#### 推送代码到gitlab

推送代码的几种情况

```shell
命令行指引
您还可以按照以下说明从计算机中上传现有文件。


Git 全局设置
Git 全局设置
git config --global user.name "Administrator"
git config --global user.email "admin@example.com"

克隆一个新仓库
git clone http://192.168.37.136/root/test.git
cd test
touch README.md
git add README.md
git commit -m "add README"
git push -u origin master


推送现有文件夹
cd existing_folder
git init
git remote add origin http://192.168.37.136/root/test.git
git add .
git commit -m "Initial commit"
git push -u origin master


推送现有的 Git 仓库
cd existing_repo
git remote rename origin old-origin
git remote add origin http://192.168.37.136/root/test.git
git push -u origin --all
git push -u origin --tags
```





#### 在另一台客户端获取代码

注意：另外一台客户端要在root配置认证ssh key

```shell
1.若是本地没有代码仓库，首次可以直接git clone获取代码
[root@git-server ~]# git clone http://192.168.37.136/root/test.git
正克隆到 'test'...
Username for 'http://192.168.37.136': root
Password for 'http://root@192.168.37.136': 
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 5 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (5/5), done.
[root@git-server ~]# ls
anaconda-ks.cfg  test


2.可以进入代码仓库，编写代码后提交
[root@git-server test]# echo '我是新用户'>new.txt
[root@git-server test]# ls
123.txt  hello.txt  new.txt
[root@git-server test]# git add .
[root@git-server test]# git commit -m 'commit new.txt'
[master 193de4a] commit new.txt
 1 file changed, 1 insertion(+)
 
[root@git-server test]# git remote 
origin


[root@git-server test]# git push -u origin master
Username for 'http://192.168.37.136': root
Password for 'http://root@192.168.37.136': 
Counting objects: 4, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 288 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To http://192.168.37.136/root/test.git
   3571130..193de4a  master -> master


3.此时代码已经推送到远程仓库
```



#### 推送分支代码

```shell
# 新建分支，且切换
[root@git-clinet2 test]# git branch dev
[root@git-clinet2 test]# git branch
  dev
* master

[root@git-server test]# git checkout dev
切换到分支 'dev'
[root@git-clinet2 test]# git branch
* dev
  master
[root@git-s

# 分支下，开发代码，且commit
[root@git-clinet2 test]# echo "我是dev分支下的代码" > dev.txt
[root@git-clinet2 test]# git add .
[root@git-clinet2 test]# git commit -m "add dev.txt  by dev."
[dev f1e7cd5] add dev.txt  by dev.
 1 file changed, 1 insertion(+)
 create mode 100644 dev.txt


 #代码推送
[root@git-clinet2 test]# git push -u origin dev
Counting objects: 11, done.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (11/11), 875 bytes | 0 bytes/s, done.
Total 11 (delta 2), reused 7 (delta 1)
remote: 
remote: To create a merge request for dev, visit:
remote:   http://192.168.37.136/root/test/merge_requests/new?merge_request%5Bsource_branch%5D=dev
remote: 
To git@192.168.37.136:root/test.git
 * [new branch]      dev -> dev
Branch dev set up to track remote branch dev from origin.


```

此时在gitlab项目中，已然生成了dev分支，且可以看到分支下的代码

![image-20201118182218249](notes/image-20201118182218249.png)

![image-20201118182233826](notes/image-20201118182233826.png)



#### 合并分支且推送gitlab

dev开发了新功能，领导在确认无误后，决定给合并到master分支，线上运行的就是master主干分支的代码

```shell
1.在本地合并分支
[root@git-clinet2 test]# git checkout master
Switched to branch 'master'
[root@git-clinet2 test]# git merge dev
Updating 193de4a..f1e7cd5
Fast-forward
 dev.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 dev.txt
 

2.本地合完了代码，还得推送到gitlab才行、提供完整的版本内容
git push -u origin master
```

此时master和dev都有相同的代码了。

![image-20201118210535115](notes/image-20201118210535115.png)

![image-20201118210917006](notes/image-20201118210917006.png)



#### 推送tag

```shell
[root@git-clinet2 test]# git tag -a "v1.0" -m "first tag."
[root@git-clinet2 test]# git tag
v1.0
[root@git-clinet2 test]# git tag
v1.0
[root@git-clinet2 test]# git push origin v1.0
Counting objects: 1, done.
Writing objects: 100% (1/1), 154 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@192.168.37.136:root/test.git
 * [new tag]         v1.0 -> v1.0

```



![image-20201118183822140](notes/image-20201118183822140.png)









#### Gitlab备份、恢复、升级

对 gitlab 进行备份将会创建一个包含所有库和附件的归档文件。对备份的恢复只能恢 复到与备份时的 gitlab 相同的版本。将 gitlab 迁移到另一台服务器上的最佳方法就是通过 备份和还原。gitlab提供了一个简单的命令行来备份整个gitlab，并且能灵活的满足需求。

##### 修改备份配置

备份文件将保存在配置文件中定义的 backup_path 中，文件名为 TIMESTAMP_gitlab_backup.tar,TIMESTAMP 为备份时的时间戳。TIMESTAMP 的格式为: EPOCH_YYYY_MM_DD_Gitlab-version。

默认的备份文件目录为:/var/opt/gitlab/backups，如果自定义备份目录需要赋予目 录 git 权限，具体操作如下:

```shell
# 修改默认存放路径，修改配置文件
vim /etc/gitlab/gitlab.rb

# 打开参数，备份默认保留七天
gitlab_rails['backup_keep_time'] = 604800
gitlab_rails['backup_path'] = "/data/backups/gitlab"

# 执行如下命令，重新加载gitlab
[root@lb02 ~]# mkdir -p /data/backups/gitlab
[root@lb02 ~]# chown -R git.git /data/backups/gitlab
[root@lb02 ~]# gitlab-ctl reconfigure

# 手动备份，此时就会在对应的备份目录下，产生数据
[root@lb02 ~]# gitlab-rake gitlab:backup:create
done
done
done
done
done
done
done
Deleting old backups ... done. (0 removed)
Warning: Your gitlab.rb and gitlab-secrets.json files contain sensitive data 
and are not included in this backup. You will need these files to restore a backup.
Please back them up manually.
Backup task is done.

#备份完成后会在/data/backups/gitlab下生成数据
[root@git-clinet2 gitlab]# ls
1605706686_2020_11_18_12.0.3_gitlab_backup.tar


```

#### 定时备份

对于数据安全，备份操作可以进行定时任务添加，做到每天备份一次。

```shell
[root@lb02 gilab]# crontab -l
0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create &>/dev/null
```





#### 数据恢复

Gitlab的恢复只能恢复到与原本备份文件相同的gitlab版本中，恢复时，需要停止数据库的写入操作，但是保持gitlab是运行的。

暂停数据库写入

```shell
[root@git-clinet2 test]# gitlab-ctl stop unicorn
ok: down: unicorn: 0s, normally up

[root@git-clinet2 test]# gitlab-ctl stop sidekiq
ok: down: sidekiq: 0s, normally up

[root@git-clinet2 test]# gitlab-ctl status
run: alertmanager: (pid 1553) 1346s; run: log: (pid 1552) 1346s
run: gitaly: (pid 1535) 1347s; run: log: (pid 1530) 1347s
run: gitlab-monitor: (pid 1543) 1347s; run: log: (pid 1542) 1347s
run: gitlab-workhorse: (pid 1537) 1347s; run: log: (pid 1536) 1347s
run: grafana: (pid 1549) 1346s; run: log: (pid 1547) 1347s
run: logrotate: (pid 1545) 1347s; run: log: (pid 1544) 1347s
run: nginx: (pid 1532) 1347s; run: log: (pid 1531) 1347s
run: node-exporter: (pid 1548) 1346s; run: log: (pid 1546) 1347s
run: postgres-exporter: (pid 1555) 1346s; run: log: (pid 1554) 1346s
run: postgresql: (pid 1534) 1347s; run: log: (pid 1533) 1347s
run: prometheus: (pid 1556) 1346s; run: log: (pid 1550) 1346s
run: redis: (pid 1529) 1347s; run: log: (pid 1528) 1347s
run: redis-exporter: (pid 1557) 1346s; run: log: (pid 1551) 1346s
down: sidekiq: 8s, normally up; run: log: (pid 1540) 1347s
down: unicorn: 17s, normally up; run: log: (pid 1538) 1347s

```

测试数据恢复

1.先删除原有的项目

![image-20201118215818227](notes/image-20201118215818227.png)

![image-20201118215832838](notes/image-20201118215832838.png)



![image-20201118215957942](notes/image-20201118215957942.png)



#### 



进行数据恢复

整个恢复过程基本是在删除表，创建表。

```shell
# 只需要填写备份文件的时间戳信息即可
gitlab-rake gitlab:backup:restore BACKUP=1605706686_2020_11_18_12.0.3
Unpacking backup ... done
Before restoring the database, we will remove all existing
tables to avoid future upgrade problems. Be aware that if you have
custom tables in the GitLab database these tables and all data will be
removed.

Do you want to continue (yes/no)? yes
```

重新启动gitlab数据库

```shell
gitlab-ctl restart
```

重新访问gitlab，可以用`gitlab-ctl tail`查看日志信息

```shell
http://192.168.37.136/
```

![image-20201118220621265](notes/image-20201118220621265.png)



#### 升级操作

升级操作不建议操作，只需做了解过程即可，或者再建一台虚拟机操作

```shell
1.关闭gitlab自带的服务
[root@lb02 gilab]# gitlab-ctl stop unicorn
[root@lb02 gilab]# gitlab-ctl stop sidekiq
gitlab-ctl stop nginx

2.立即备份现有gitlab数据
gitlab-rake gitlab:backup:create

3.下载新版本的gitlab软件包

4.直接安装新版本
yum localinstall 新版gitlab

如果出现报错，解决办法如下
//报错.
Error executing action `run` on resource 'ruby_block[directory resource: /var/opt/gitlab/git-data/repositories]'

//解决方法:
[root@gitlab-ce ~]# chmod 2770 /var/opt/gitlab/git-data/repositories

5.安装完毕后，启动gitlab即可
gitlab-ctl reconfigure
gitlab-ctl restart
# 查看gitlab版本
head -1 /opt/gitlab/version-manifest.txt
```



### 10.20、Jenkins介绍



# jenkins

## 代码上线发展史

代码发布上线是每一个 IT 企业必须要面临的，而且不管是对开发或者是运维来说，代 码上线本身就是一个件非常痛苦的事情，很多时候每一次发布都是一次考验。为了提高上线 的效率，代码上线的方式，方法，工具也不断的发展，基本上可以分为以下几个阶段。

### 没有构建服务器

软件在开发者的机器上通过脚本或者手动构建，源代码保存在代码服务器中，但是开发者经常要修改本地代码，因此每次发布，都需要手动合并代码，再进行手动构建，这个过程费时费力。

### 晚上进行构建

在这个阶段，团队有构建服务器，自动化的构建在晚上进行。构建过程只是简单的编译代码，没有可靠的和可重复的单元测试。然而，开发人员每天提交代码。如果某个开发人员 提的代码和其他人的代码冲突的话，构建服务器会在第二天通过邮件通知团队。所以又一段 时间构建是处于失败状态的。

### 晚上进行构建并进行自动化测试

团队对 CI 和自动化测试越来越重视。无论什么时候版本管理系统中的代码改变了都会 触发编译构建过程，团队成员可以看到是代码中的什么改变触发了这个构建。并且，构建脚本会编译应用并且会执行一系列的单元测试或集成测试。除了邮件，构建服务器还可以通过 其他方式通知团队成员，如微信，钉钉通知。

### 代码质量度量

自动化的代码质量和测试覆盖率的度量手段有助于评价代码质量和测试的有效性。

### 更加认真的对待测试

CI和测试紧密相关，如今测试驱动开发被广泛的使用，是的对自动化的构建更加有信心。应用不仅仅是简单的编译和测试，而是如果测试成功会被自动的部署到一个应用服务器，以此进行更多的测试工作与性能测试。

### 验收测试与自动化部署

验收测试驱动的开发被使用，使得我们能够了解项目的状态。这些自动化的测试使用行 为驱动的开发和测试驱动的开发工具来作为交流和文档工具，发布非开发人员也能读懂的测 试结果报告。由于测试在开发的早起就已经被自动化的执行了，所以我们能更加清楚地了解 到什么已经做了，什么还没有做。每当代码改变或晚上，应用被自动化地部署到测试环境中， 以供 QA 团队测试。当测试通过之后，软件的一个版本将被手工部署到生产环境中，团队也可以在出现问题的时候回滚之前的发布记录。



### 具体的持续集成概念介绍可阅读10.1章节的知识



### 10.21、Jenkins的安装



## centos7安装jenkins

最小硬件需求:256M 内存、1G 磁盘空间，通常根据需要 Jenkins 服务器至少 1G 内存， 50G+磁盘空间。

软件需求：由于jenkins是使用java语言开发，因此运行需要安装java运行时环境（jdk）。

所有软件包可以找超哥索取，qq：877348180

```shell
[root@jenkins-server opt]# ls
jdk-8u121-linux-x64.rpm  jenkins-2.99-1.1.noarch.rpm
```

## 配置jdk环境

可以通过清华镜像站下载jenkins安装包，以及jdk环境可以通过yum直接安装，也可以下载好rpm包安装

```shell
[root@jenkins-server opt]# rpm -ivh jdk-8u121-linux-x64.rpm 
Preparing...                          ################################# [100%]
Updating / installing...
   1:jdk1.8.0_121-2000:1.8.0_121-fcs  ################################# [100%]
Unpacking JAR files...
	tools.jar...
	plugin.jar...
	javaws.jar...
	deploy.jar...
	rt.jar...
	jsse.jar...
	charsets.jar...
	localedata.jar...

[root@jenkins-server opt]# java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
```





## 安装jenkins

安装方式有很多，这里用rpm安装

```shell
[root@jenkins-server opt]# rpm -ivh jenkins-2.99-1.1.noarch.rpm 
warning: jenkins-2.99-1.1.noarch.rpm: Header V4 DSA/SHA1 Signature, key ID d50582e6: NOKEY
Preparing...                          ################################# [100%]
Updating / installing...
   1:jenkins-2.99-1.1                 ################################# [100%]



# 检查jenkins版本
[root@jenkins-server opt]# java -jar /usr/lib/jenkins/jenkins.war --version
2.99

```

## 启动jenkins

```shell
[root@jenkins-server opt]# systemctl start jenkins
[root@jenkins-server opt]# systemctl status jenkins


[root@jenkins-server opt]# netstat -tunpl|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN      2491/java   


# 注意关闭防火墙
iptables -F
```





### 10.22、jenkins配置与初始化





## jenkins配置文件

学习jenkins首先要明白一点，那就是jenkins一切皆文件，jenkins没有数据库，所有的数据都是以文件的形式存在，所以我们要了解jenkins的主要目录和文件。

```shell
[root@jenkins-server opt]# rpm -ql jenkins
/etc/init.d/jenkins
/etc/logrotate.d/jenkins
/etc/sysconfig/jenkins
/usr/lib/jenkins
/usr/lib/jenkins/jenkins.war
/usr/sbin/rcjenkins
/var/cache/jenkins
/var/lib/jenkins
/var/log/jenkins



jenkins加载插件很多，非常吃内存，且所有操作都是io操作，需要系统IO速度较快，需要机器配置较高
jenkins配置文件：/etc/sysconfig/jenkins
jenkins核心目录：/var/lib/jenkins
/usr/lib/jenkins/jenkins.war WAR包
/etc/sysconfig/jenkins 配置文件
/var/lib/jenkins/ 默认的JENKINS_HOME目录
/var/log/jenkins/jenkins.log Jenkins日志文件
/var/lib/jenkins/secrets/initialAdminPassword 存放初始密码
/var/lib/jenkins/plugins    插件目录
```



## jenkins初始化

jenkins首次启动可能会出现页面访问一直提示：

![image-20200326114330567](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200326114330567.png)

```shell
访问  192.168.37.101:8080  jenkins站点

一直显示"Please wait while Jenkins is getting ready to work ..." 无法进入
```

进行如下修改

```shell
[root@jenkins-server jenkins]# pwd
/var/lib/jenkins

cp hudson.model.UpdateCenter.xml hudson.model.UpdateCenter.xml.bak

# 修改如下配置
cat hudson.model.UpdateCenter.xml
<?xml version='1.0' encoding='UTF-8'?>
<sites>
  <site>
    <id>default</id>
    <url>http://mirror.xmission.com/jenkins/updates/update-center.json</url>
  </site>
</sites>


systemctl reload jenkins
systemctl restart jenkins
```

这个过程会比较缓慢





### 解锁jenkins

![image-20201119165725717](notes/image-20201119165725717.png)



```shell
# 默认账号admin，密码如下
[root@jenkins-server opt]# cat /var/lib/jenkins/secrets/initialAdminPassword
1dff05707d954a888d24ebf7496ce6f3

```



### 自定义jenkins插件

这里安装插件由于会非常缓慢，我们可以后期手动安装，直接点击右上角的❎

![image-20200326111739187](notes/image-20200326111739187.png)

此时进入jenkins首页

![image-20200326121053474](notes/image-20200326121053474.png)



![image-20201119170335775](notes/image-20201119170335775.png)

默认没安装插件，所以页面功能很少



### 修改jenkins用户密码



![image-20201119170651489](notes/image-20201119170651489.png)

```
默认admin密码太长，可以修改自己记住的
jenkins
```

修改完后提示用户id为admin

![image-20201119170744334](notes/image-20201119170744334.png)



### 10.23、jenkins的插件管理



## 插件安装

国外jenkins插件安装太难了，请用如下方式

![image-20200326172057229](notes/image-20200326172057229.png)![image-20200326172813498](notes/image-20200326172813498.png)

### 指定jenkins代理下载插件

可以配置下载插件代理地址

也可以去官网、清华源等地址手动下载jenkins插件，再上传

```
jenkins镜像文件后缀`.hpi`文件
```

![image-20200326172847784](notes/image-20200326172847784.png)

### 使用清华镜像站下载插件

```shell
https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/

下载.hpi文件，然后在jenkins里面导入上传即可，自动安装，重启生效
```

### 修改jenkins默认升级插件源

```
如图，换为
https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json

点击提交，也就是修改了linux的文件hudson.model.UpdateCenter.xml
```

![image-20200326173740074](http://book.luffycity.com/linux-book/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/pic/image-20200326173740074.png)









### jenkins插件迁移

```shell
可以把插件备份的机器，所有的插件目录/var/lib/jenkins/plugins 资料直接打包
解压缩到新插件目录即可，jenkins一切皆文件，可以直接迁移

jenkins没有数据库，一切皆文件，都是写在xml文件里

超哥已经提供了插件压缩包
/opt/ci_cd_rpm/plugins.tar.gz

# 解压缩
[root@m01 ci_cd_rpm]# tar -zxvf plugins.tar.gz
# 复制，移动所有插件到当前jenkins的插件目录

[root@m01 plugins]# pwd
/opt/ci_cd_rpm/plugins
[root@m01 plugins]#
[root@m01 plugins]# mv * /var/lib/jenkins/plugins/

# 重启jenkins，查看插件列表
systemctl restart jenkins

# 重启之后，jenkins自动应用所有新插件，且正确应用了
```

## 查看插件列表

```shell
系统管理 > 系统信息 >  插件

系统管理 > 插件管理 > 已安装
```

### 新功能预览

```shell
jenkins首页 > 新建Item > 多了很多新功能
```



### 10.24、jenkins的主要目录

## Jenkins主目录学习

```shell
[root@m01 plugins]# rpm -ql jenkins
/etc/init.d/jenkins                    # 启动目录
/etc/logrotate.d/jenkins        # 日志切割
/etc/sysconfig/jenkins          # jenkins主配置文件
/usr/lib/jenkins                        #jenkins程序文件 jenkins.war，如 直接替换新版jenkins.war包，重启即升级
/usr/lib/jenkins/jenkins.war
/usr/sbin/rcjenkins
/var/cache/jenkins
/var/lib/jenkins                      # jenkins主目录，如果要备份jenkins所有数据，直接拷贝这个目录即可
/var/log/jenkins
```





### 10.25、jenkins修改时区



## 修改jenkins时区

```shell
打开jenkins的【系统管理】---> 【脚本命令行】
在命令框中输入一下命令【时间时区设为 亚洲上海】

System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')
```

![image-20200327165046301](notes/image-20200327165046301.png)



### 10.26、jenkins之创建项目（freestyle-job）



## Jenkins创建job

构建作业是一个持续集成服务器的基本职能，构建的形式多种多样，可以是编译和单元测试，也可能是打包及部署，或者是其他类似的作业。在 Jenkins 中，构建作业很容 易建立，而且根据你的需要你可以安装各种插件，来创建多种形式的构建作业，下面我们先来学习创建自由式构建作业。

自由式的构建作业是最灵活和可配置的选项，并且可以用于任何类型的项目，它的配置 相对简单，其中很多配置在的选项也会用在其他构建作业中。

在 Jenkins 主页面，点击左侧菜单栏的“新建”或者“New job”

### freestyle-job介绍

- 自由风格项目，比较灵活，可以构建任何形式的项目
- 在页面添加模块配置与参数
- 每个job仅能实现一个开发功能
- 无法将配置代码化，不利于Job配置迁移和版本控制
- 学习相对简单

### Jenkins创建freestyle项目

![image-20201119223853187](notes/image-20201119223853187.png)

```shell
1.输入任务名字，job名字，定义一个有意义的名字，根据业务命名
注意，一旦确定job名字，就不要轻易修改了，jenkins一切皆文件
job名字已经被写入各种配置了，生成一系列的文件，文件夹

[root@jenkins-server jobs]# pwd
/var/lib/jenkins/jobs
[root@jenkins-server jobs]# ls
My freestyle job




如果你修改了文件夹，这里会生成一个新的job文件夹配置，数据目录就会紊乱出错
```



勾选“丢弃旧的构建”，这是我们必须提前考虑的重要方面，就是我们如何处理构建历史，构建作业会消耗大理的磁盘空间，尤其是你存储的构建产物(比如执行 java 构建时会 生成的 JAR、WAR 等)。

![image-20201119224041707](notes/image-20201119224041707.png)

选项允许你限制在构建历史记录的作业数。你可以告诉 Jenkins 只保留最近的几次构 建，或者只保留指定数量的构建，此外，Jenkins 永远不会删除最后一个稳定和成功的构建。 具体数据的指定要根据你项目的实际情况而定，我一般设置为 5、5

```shell
丢弃旧的构建
如果项目特别多，文件大，会造成jenkins数据目录过大，特别是编译类型的项目
    保持构建5天
    保留构建最大个数5个 

构建触发器
    手动构建
    定义触发器


构建环境

构建
    执行一系列的操作
    Execute shell
        执行linux命令
```





### 10.27、jenkins获取gitlab仓库源码



# Jenkins连接gitlab获取代码

既然是持续集成，对代码进行构建，我们得获取代码仓库的内容，这里选择我们搭建的gitlab服务器

## **友情提醒**

**1.在自己虚拟机做实验，若是gitlab，jenkins运行在一台服务器，内存需要给大一点，该两个服务非常吃内存**

```shell
[root@gitlab-sever /]# free -h
              total        used        free      shared  buff/cache   available
Mem:           3.8G        2.8G        674M         54M        343M        653M
Swap:          3.9G        563M        3.3G

```

**2.jenkins会和gitlab冲突端口，8080，修改jenkins端口来的方便**

```shell
 grep 9080 /etc/sysconfig/jenkins
JENKINS_PORT="9080"

重启jenkins
systemctl restart jenkins

#下面是两个机器不用更改、不冲突
```

## 环境准备

1.服务配置

```shell
git服务器：192.168.37.100
jenkins服务器：192.168.37.101

1.启动gitlab，且检查
gitlab-ctl restart/status 

2.启动jenkins，且检查
systemctl start/status jenkins

```



2、从码云上获取html代码到gitlab



![image-20201119225926870](notes/image-20201119225926870.png)



复制url

![image-20201119225941284](notes/image-20201119225941284.png)





在gitlab创建用户组

![image-20201119230321627](notes/image-20201119230321627.png)





![image-20201119230252604](notes/image-20201119230252604.png)





创建用户

![image-20201119230429643](notes/image-20201119230429643.png)



![image-20201119230505643](notes/image-20201119230505643.png)



关联用户到用户组

![image-20201119230547480](notes/image-20201119230547480.png)





导入源码项目

![image-20201119230615860](notes/image-20201119230615860.png)

![image-20201119230629219](notes/image-20201119230629219.png)



![image-20201119230753492](notes/image-20201119230753492.png)





![image-20201119230827899](notes/image-20201119230827899.png)

此时正在获取代码、取决于远程库的文件大小、稍做等待



![image-20201119231017836](notes/image-20201119231017836.png)

已经获取成功了、代码准备完成、接下就是配置jenkins与gitlab连通



### 10.28、配置jenkins结合gitlab

在gitlab上复制仓库地址

![image-20201119231257680](notes/image-20201119231257680.png)

```shell
git@192.168.37.100:operations/monitor.git
```



### jenkins配置添加gitlab

在jenkins上找到job配置页面，下拉到`源码管理`，勾选git管理

![image-20201120110547366](notes/image-20201120110547366.png)



![image-20201120110528291](notes/image-20201120110528291.png)

注意：

1.该jenkins服务器的git安装有问题、可以进行如下操作；

```shell
yum install git -y  #进行升级
```

升级后还是报错、解决第2个问题



2.这里报错说明jenkins机器没有和gitlab进行认证、无法信息jenkins这个主机

```shell
解决办法：

#生成jenkins机器的公私钥
[root@jenkins-server /]# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:nMtklzP2VLKfBLfx+m7ch0ZVDdAmydpNDfTLWmcuYlI root@jenkins-server
The key's randomart image is:
+---[RSA 2048]----+
|           ..=++.|
|            + +.+|
|           oo=+ o|
|       . ....*o+o|
|        S * E o=+|
|       + + * o+=.|
|        o . +o=oo|
|           o .oo=|
|             . o+|
+----[SHA256]-----+

#查看公钥并复制到gitlab的root的ssh key

[root@jenkins-server /]# cat /root/.ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCxD7E+xL13e3dD7rFoYOsTvfZvfpqbm1WyRh0xD23VQy1p8aGEaiU0fQ73H0XfzjnS6t0FYdPuEp4JBGK+fQSDQhzWsivWYyM0m2yIwipSpMQNJMS7va1L6dbvm6fGlZlWJ+AzD+jC8GsLWK9dpdaiywm+qncBq+QPmZjPVgoDSUO6ZvcLR2LtIpRwnLiDnTx/7YByUHtuTonrKW5pRJlj+SIYspIyl1NTa2y8Z1OxAa77g3TPltC5ZZlm9OObUhYqGvtpJc+jmX4NmcVjW+HamzPDWyPv5ZBW/KdYqEImKC2+mc3WOkRfbDQO2P7441gSIDvhpfaohvQpCLF3isb5 root@jenkins-server


```



### gitlab上配置ssh key

![image-20201120113048487](notes/image-20201120113048487.png)

已经成功添加公钥

![image-20201120112947325](notes/image-20201120112947325.png)



再次回到jenkins、发现还是报错

![image-20201120130223859](notes/image-20201120130223859.png)



由于我们是用的jenkins用户启动的jenkins服务、因此要将jenkins机器上的私钥发给gitlab进行公私钥校验比对

```shell
[root@jenkins-server /]# ps -ef|grep java
jenkins    4374      1  0 19:16 ?        00:00:57 /etc/alternatives/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -jar /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --daemon --httpPort=8080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=20
```



###  解决jenkins用户启动jenkins的认证问题

```shell
#查看私钥
[root@jenkins-server /]# cat /root/.ssh/id_rsa
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAsQ+xPsS9d3t3Q+6xaGDrE732b36am5tVskYdMQ9t1UMtafGh
hGolNH0O9x9F38450urdBWHT7hKeCQRivn0Eg0Ic1rIr1mMjNJtsiMIqUqTEDSTE
u72tS+nW75unxpWZVifgMw/owvBrC1ivXaXWossJvqp3AavkD5mYz1YKA0lDumb3
C0di7SKUcJy4g508f+2AclB7bk6J6yluaUSZY/kiGLKSMpdTU2tsvGdTsQGu+4N0
z5bQuWWZZvTjm1IWKhr7aSXPo5l+DZnFY1vh2pszw1sj7+WQVvynWKhCJigtvpnN
1jpEX2w0Dtj++ONYEiA74aX2qIb0KQixd4rG+QIDAQABAoIBACBNMJS256nIiHWI
Mi1MoRY07aRhgGsq53NifyjYG71wR/Sv9Dtn8emldvl2ZxTxVnM4DaJRuowQMWyL
tEf0HsKjaQdx8bVm2KFcSWyZn4b8MBgFwS5O6DKVMnT7/Jup5xNkqu4l1NzbZ2vm
ffejrYh9agWyq4tOhIikCNCqbaEziobeXbcrzVDFAvCw1C8NweXYT+M1t65K9Lma
RXeKK6xolvzQrUpR8Lg+QM3Imr+n+k7o/amgvPTjsalpND9XmoDlFkexYy7OvsJA
cepe/DWDHA79dqZ2RxveFniL/zWp95Gq042MBNEPmTYu7pLWTEt3FpORXMcEHc1c
kyYj+5ECgYEA55Blaf7dKRWYrO2XrXP+O9EyAJYgjGL6jNYDVtg6cufqMdHVwd3u
fAWZaqCu69eKVGC7q/OVD9kQA6aO740w3h1pySSKPfbEYOme0YJIUArGa11qPqfH
YU6myNUbsKXxAf/rZgWrQ49XbaRWJnt0sr1EQrXATeKCf292vGsck18CgYEAw77t
fznyZRTl5VWLv2/Y4UIrfTccQjUnN0+U8I7n/m6bKADPaGBS9RABQ17sYdk8jsmk
/9/lLXE8WZp7Ep6evQydg9+NCHa/aVhp3MeesPoR5sIQorw8YjQpSFFOkJvauyBa
h9a8AMopn9YqssRqS+C8EZwYsp1mwvmVX0df3KcCgYBvMalhIp80kUhFEboZ8m8M
bkHigjSS9Rx28HWeCCrY7oBI+Af7FgTkzROEXjBg05l7NxAnW8oiWAsWla5hXZ0v
q1QW4FL5ujtGhihbVoI+3U22VJ8mAw78rPXtzleDlcuLOEbjMKmywWwsHBO6WuII
ylWy6u+y9qfPZcjQZWbNZQKBgQCMX6FFebLAlmn/OofLM1RexesWEq1rNV74JVPz
5yerqHoQB/S1L06Oe3nMbIgr63OoGib/b/qTyf6zazsTMTk47ZEP/wLOrQm7bDIO
qAC/fbXUvBrd+Qt8iVeJivVCcuI7C4qgm3ebQV70Rsu8A2sPGw0Du+NiQ8przDw4
ZaDzRQKBgQDCSTP9XdRBmLfqA7viXuKbtBLQECBmFWTMXbQerD8fjc3YuZ2wgDmZ
t8ozoDm4XwOgs5f1K3U9KnmDnkfceTKLzY7AE+GJPvaHZp0t3AyXtc7Q6YWWsVUJ
Q75zmy6a4MZuUs/M1uf+HGKVjb/y2luYDO5+WGrr7ZVbDps7eF3/CQ==
-----END RSA PRIVATE KEY-----

```



![image-20201120130657511](notes/image-20201120130657511.png)



![image-20201120132012005](notes/image-20201120132012005.png)



![image-20201120130730768](notes/image-20201120130730768.png)





### 启用job、进行立即构建

点击立即构建



![image-20201120132253734](notes/image-20201120132253734.png)



查看构建结构

![image-20201120132402236](notes/image-20201120132402236.png)



### 查看构建结果

![image-20201120132444087](notes/image-20201120132444087.png)





### 查看My-freestyle-job的工作区

```shell
已经是下载完毕了代码
[root@jenkins-server My-freestyle-job]# pwd
/var/lib/jenkins/workspace/My-freestyle-job
[root@jenkins-server My-freestyle-job]# ls
404.html       components.html          energy_consumption.html  form-validation.html  labels.html     messages.html            readme.md
alerts.html    content-widgets.html     file-manager.html        images-icons.html     LICENSE         mstp_105_SuperAdmin.iml  real-time.html
assets         css                      fonts                    img                   list-view.html  mstp_map.html            sa.html
buttons.html   deviceManager.html       form-components.html     index.html            login.html      other-components.html    tables.html
calendar.html  dianfei.html             form-elements.html       js                    media           profile-page.html        typography.html
charts.html    efficiencyAnalysis.html  form-examples.html       keyInfo.html          media.html      QHME.iml                 userMng.html

```





### 10.29、jenkins获取代码部署html网站

#### 再准备一台机器上安装apache

```shell
yum install httpd -y
```

启动httpd

```shell
ystemctl start httpd
netstat -tunpl|grep httpd
tcp6       0      0 :::80                   :::*                    LISTEN      11516/httpd 
```



看到如下界面说明，http搭建成功

![image-20201120133444665](notes/image-20201120133444665.png)



将代码放到http的代码目录下

```shell
1.查看http的配置文件、找到代码目录

vim /etc/httpd/conf/httpd.conf 
部分代码如下：

DocumentRoot "/var/www/html"

#
# Relax access to content within /var/www.
#
<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>

# Further relax access to the default document root:
<Directory "/var/www/html">


2.将代码放到/var/www/html

mv /var/lib/jenkins/workspace/My-freestyle-job/* /var/www/html/

[root@jenkins-server My-freestyle-job]# cd /var/www/html/
[root@jenkins-server html]# ls
404.html       components.html          energy_consumption.html  form-validation.html  labels.html     messages.html            readme.md
alerts.html    content-widgets.html     file-manager.html        images-icons.html     LICENSE         mstp_105_SuperAdmin.iml  real-time.html
assets         css                      fonts                    img                   list-view.html  mstp_map.html            sa.html
buttons.html   deviceManager.html       form-components.html     index.html            login.html      other-components.html    tables.html
calendar.html  dianfei.html             form-elements.html       js                    media           profile-page.html        typography.html
charts.html    efficiencyAnalysis.html  form-examples.html       keyInfo.html          media.html      QHME.iml                 userMng.html

3.访问：192.168.37.1001
```

![image-20201120135852469](notes/image-20201120135852469.png)



### 10.31、jenkins通过脚本自动部署



#### 环境准备

```
http机器:192.168.37.102--部署好htppd
jenkins机器：192.168.37.101--编写好脚本
```



```shell
#创建脚本存放路径
[root@jenkins-server /]# mkdir -p /server/scripts

#发送公钥给服务器，配置公钥登录
ssh-copy-id root@192.168.37.102
就可以在jenkins机器上进行免密登录

#编写脚本
[root@jenkins-server scripts]# pwd
/server/scripts

[root@jenkins-server monitor]# cat /server/scripts/web01.sh 
#!/bin/bash

bag_name=web-$(date +%F)_$(($RANDOM+10000))
host=$1
host2=$2

cd /monitor && tar -zcf /monitor/${bag_name}.tar.gz ./*  \

ssh root@${host} "cd /var/www/ && mkdir ${bag_name}" \


scp /monitor/${bag_name}.tar.gz  root@${host}:/var/www/${bag_name} \

ssh root@${host} "cd /var/www/${bag_name}  && tar -zxf ${bag_name}.tar.gz" \

ssh root@${host} "cd /var/www/${bag_name}   && rm -rf ${bag_name}.tar.gz /var/www/html" \

ssh root@${host} "ln -s /var/www/${bag_name} /var/www/html " \


#测试脚本
[root@jenkins-server monitor]# sh /server/scripts/web01.sh  192.168.37.102
web-2020-11-20_23895.tar.gz                                                                                               100% 9086KB 114.7MB/s   00:00    
[root@jenkins-server monitor]# sh /server/scripts/web01.sh  192.168.37.102
web-2020-11-20_38224.tar.gz                                                                                               100%   18MB


[root@http-server www]# ll
total 12
drwxr-xr-x. 2 root root    6 Nov 17 00:19 cgi-bin
lrwxrwxrwx. 1 root root   29 Nov 20 23:51 html -> /var/www/web-2020-11-20_38224
drwxr-xr-x. 8 root root 4096 Nov 20 23:50 web-2020-11-20_23895
drwxr-xr-x. 8 root root 4096 Nov 20 23:51 web-2020-11-20_38224
drwxr-xr-x. 8 root root 4096 Nov 20 23:49 web-2020-11-20_42430


```



手动测试访问网页

![image-20201120152546082](notes/image-20201120152546082.png)



### 结合jenkins实现脚本自动化部署



回到项目管理、选择构建、执行脚本

![image-20201120153213422](notes/image-20201120153213422.png)



![image-20201120163210320](notes/image-20201120163210320.png)



保存、并执行构建

![image-20201120163300259](notes/image-20201120163300259.png)





发现报错、由于之前的配置的jenkins配置了sudo后、还需要输入密码

![image-20201120163350134](notes/image-20201120163350134.png)



解决方法如下

```shell
192.168.37.102是传入的参数

#由于启动jenkins是jenkins用户执行，所以要给与jenkin能够使用sudo权限



#赋予权限
[root@jenkins-server /]# chmod 740 /etc/sudoers
[root@jenkins-server /]# ll /etc/sudoers
-rwxr----- 1 root root 3985 Nov 21 00:17 /etc/sudoers

#修改为如下内容
[root@jenkins-server /]# vim /etc/sudoers
root    ALL=(ALL)       ALL
jenkins ALL=NOPASSWD:ALL					#这里表示不用使用密码就可以执行sudo
syh ALL=NOPASSWD:ALL


#保存后、再把文件修改为440
[root@jenkins-server /]# chmod 440 /etc/sudoers
[root@jenkins-server /]# ll /etc/sudoers
-r--r----- 1 root root 3985 Nov 21 00:17 /etc/sudoers

#退出sudo模式后、用syh进行测试
[root@jenkins-server /]# su - syh
[syh@jenkins-server /]$ sudo mkdir 66
[syh@jenkins-server /]$ ls

[syh@jenkins-server /]$ ls
66  bin  boot  dev  etc  git  haha.txt  home  lib  lib64  media  mnt  monitor  opt  proc  root  run  sbin  server  srv  sys  tmp  usr  var

```

再次执行构建

![image-20201120164111682](notes/image-20201120164111682.png)

![image-20201120164425214](notes/image-20201120164425214.png)





### 10.32构建触发器

这里构建触发器的目的是、当gitlab上的分支出现变化（提交新代码）时，然后告诉jenkins自动执行触发构建、不用自己去点击构建

#### jenkins配置触发器

![image-20201120165526252](notes/image-20201120165526252.png)



```shell
master:当分支出现变更、也就是最后合并到master、当master出现变更时触发构建
token：表示gitlab出现分支变更时、告诉谁要进行出发、是个标识、对象
```



#### gitlab配置jenkins的token



![image-20201120170652113](notes/image-20201120170652113.png)

```shell
url：http://192.168.37.101:8080/project/My-freestyle-job
tonken：914f986e4a2e0783e3a9336e5ee5c5ab
```

结果测试

![image-20201120170948433](notes/image-20201120170948433.png)

返回结果

![image-20201120171051298](notes/image-20201120171051298.png)





![image-20201120171520117](notes/image-20201120171520117.png)





#### 手动发送post请求出发构建

```shell
1.克隆项目
[root@jenkins-server /]# git clone git@192.168.37.100:operations/monitor.git

2.修改git配置
[root@jenkins-server monitor]# pwd
/monitor
[root@jenkins-server monitor]# git config --global user.name "syh"
[root@jenkins-server monitor]# git config --global user.email "937921303@qq.com"
[root@jenkins-server monitor]# git config --global color.ui true 
[root@jenkins-server monitor]# git remote
origin
[root@jenkins-server monitor]# git remote add origin git@192.168.37.100:operations/monitor.git


3.修改代码内容、用git提交到仓库
修改index.html内容
        <header id="header" class="media">
            <a href="" id="menu-toggle"></a>
            <a class="logo pull-left" href="index.html" style="width: 233px">push触发自动构建2</a>

4.git添加
git add index.html 
git commit -m 'modify index.html on jenkins-server'


5.推送到仓库
 git push -u origin master
```



自动构建触发

![image-20201120190656244](notes/image-20201120190656244.png)



访问结果

![image-20201120190813467](notes/image-20201120190813467.png)



### 10.33、Jenkins返回构建状态

```shell
进入，jenkins--->系统管理--->系统配置
```

#### 填写gitlab地址

![image-20201120191359486](notes/image-20201120191359486.png)





#### 生成gitlab的token



![image-20201120191623562](notes/image-20201120191623562.png)



生成gitlab的token

```
swfFWK3gUqr72_nd2eZz
```

![image-20201120192100361](notes/image-20201120192100361.png)

#### 粘贴token到jenkins

![image-20201120192203845](notes/image-20201120192203845.png)

![image-20201120192249933](notes/image-20201120192249933.png)

选择如下

![image-20201120192312965](notes/image-20201120192312965.png)





#### 配置job

进行构建后的操作、构架后该干什么事

```shell
进人，jenkins--->My-freestyle-job-->配置----》构建后操作
```

配置如下

![image-20201120192756918](notes/image-20201120192756918.png)

#### 执行构建

当jenkins执行构建完毕后、结果会发送到gitlab

![image-20201120192933609](notes/image-20201120192933609.png)

![image-20201120192957623](notes/image-20201120192957623.png)





#### 在gitlab上查看状态

![image-20201120193124863](notes/image-20201120193124863.png)





![image-20201120193158095](notes/image-20201120193158095.png)

![image-20201120193225844](notes/image-20201120193225844.png)





### 10.34、maven的介绍

#### jakenins创建maven项目



#### Java项目部署描述

### 什么是java项目

就是java编写的代码、称之为java项目



### 为什么java项目需要编译

java编写的代码无法直接在服务器上运行、需要借助maven工具进行打包

理解：Java源代码就像汽车的一堆散件、必须组装成一辆完整的汽车、才能进行使用、组装汽车零件的过程就是java的编译过程





### 手动编译vs自动编译

手动部署：

```
得到程序员写好的java源代码
|
使用maven手动构建
|
推送war包之tomcat进行发布
```

java项目部署架构图

![image-20201121105703750](notes/image-20201121105703750.png)

手动部署Maven项目的过程非常机械化、完全可以实现自动化。

![image-20201121105854912](notes/image-20201121105854912.png)



### Maven了解

在了解Maven之前、先来看一个java项目需要的东西。首先、我们需要确定映入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j,j就需要把log4j相关的jar白放入到classpath‘中。这些就是依赖包的管理。

其次、我们要确定的项目的目录结构、例如，src目录存放java源码、resources目录存放配置文件、bin目录存放编译生成的.class文件。

此外、我们还需要配置环境，例如JDK版本、编译打包的流程、当前代码的版本号。

最后、除了使用Eclipse这样的IDE进行编译外、我们还必须通过命令工具进行编译、才能够让项目在一个独立的服务器上编译、测试、部署。

这些工作难度都不大、但是项目琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的JAVA项目管理共和构建工具。



Maven就是专门为Java项目打造的管理和构建工具、它的主要功能有：

- 提供了一套标准化的项目结构：

- 提供了一套标准化的构建过程（编译、测试、打包、发布...）;

- 提供了一套依赖管理机制





### Maven项目结构

```shell
a-maven-project
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
```





### 10.35、Maven的安装

#### 部署Maven



安装JDK

```shell
[root@jenkins-server ~]# java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
```



获取maven安装文件

```shell
1.清华镜像站
https://mirrors.tuna.tsinghua.edu.cn/apache/maven/

2.下载maven
wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz

3.解压缩，安装
tar -xf apache-maven-3.3.9-bin.tar.gz
ln -s /opt/apache-maven-3.3.9 /opt/maven

4.测试mvn命令
[root@jenkins-server local]# /opt/maven/bin/mvn -v
Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)
Maven home: /opt/maven
Java version: 1.8.0_121, vendor: Oracle Corporation
Java home: /usr/java/jdk1.8.0_121/jre
Default locale: en_HK, platform encoding: UTF-8
OS name: "linux", version: "3.10.0-862.el7.x86_64", arch: "amd64", family: "unix"


5.添加环境变量
echo "export PATH=/opt/maven/bin:$PATH" >> /etc/profile
source /etc/profile
```



### 认识maven

maven的工作目录结构

```shell
[root@jenkins-server maven]# ll /opt/maven/
total 32
drwxr-xr-x 2 root root    97 Nov 21 20:10 bin			mvn运行的脚本、连接java
drwxr-xr-x 2 root root    42 Nov 21 20:10 boot			类加载器、maven自己的类库
drwxr-xr-x 3 root root    63 Nov 11  2015 conf			配置文件目录
drwxr-xr-x 3 root root  4096 Nov 21 20:10 lib			运行java需要运行的类库
-rw-r--r-- 1 root root 19335 Nov 11  2015 LICENSE
-rw-r--r-- 1 root root   182 Nov 11  2015 NOTICE
-rw-r--r-- 1 root root  2541 Nov 11  2015 README.txt

```

### 10.36、创建maven项目

#### 环境准备

```shell
1.准备gitlab仓库的代码；
2.在jenkins上创建maven项目；生成jar包、最终上传到gitlab
3.通过jenkins获取到jar包
```

#### 创建mavrn项目

```shell
1.上传hellowaod.tar.gz包到本地
[root@jenkins-server ~]# ls
anaconda-ks.cfg  helloword  hello-world.tar.gz


2.解压缩
[root@jenkins-server ~]# tar -zxf hello-world.tar.gz 

3.查看内容内容
[root@jenkins-server ~]# cd hello-world

[root@jenkins-server hello-world]# ll
total 4
-rw-r--r-- 1 root root 1683 Aug 26  2010 pom.xml
drwxr-xr-x 4 root root   30 Oct 10  2009 src


```



#### gitlab仓库代码准备

```shell
1.创建项目
```

![image-20201121122941508](notes/image-20201121122941508.png)

```shell
2.初始化仓库


#克隆仓库到本地
[root@jenkins-server ~]# git clone  git@192.168.37.100:operations/helloword.git
[root@jenkins-server ~]# ls
anaconda-ks.cfg  helloword

#创建提交用户、邮箱
cd /root/hellowaord
git config --global user.name "su_yh"
git config --global user.email "937921303@qq.com"


#提交代码
touch test 
git add test 
git 
```





#### Maven命令

```shell
1.创建一个名为hello-world的maven项目

[root@jenkins hello-world]# tree .
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │       └── com
    │           └── juvenxu
    │               └── mvnbook
    │                   └── helloworld
    │                       └── HelloWorld.java
    └── test
        └── java
            └── com
                └── juvenxu
                    └── mvnbook
                        └── helloworld
                            └── HelloWorldTest.java

2.项目打包命令mvn package
mvn package     #此命令一定要在hello-word目录下执行
#生成target/
[root@jenkins hello-world]# cd target/
[root@jenkins target]# ll
total 8
drwxr-xr-x 3 root root   17 Nov 21 23:50 classes
-rw-r--r-- 1 root root 3132 Nov 21 23:53 hello-world-1.0-SNAPSHOT.jar
drwxr-xr-x 2 root root   28 Nov 21 23:52 maven-archiver
drwxr-xr-x 3 root root   35 Nov 21 23:50 maven-status
-rw-r--r-- 1 root root 2874 Nov 21 23:52 original-hello-world-1.0-SNAPSHOT.jar
drwxr-xr-x 2 root root  125 Nov 21 23:51 surefire-reports
drwxr-xr-x 3 root root   17 Nov 21 23:50 test-classes



3.清理mvn clean，项目临时产生的文件，一般是模块下的target目录
[root@jenkins hello-world]# mvn clean
[root@jenkins hello-world]# ll
total 4
-rw-r--r-- 1 root root 1683 Aug 26  2010 pom.xml
drwxr-xr-x 4 root root   30 Oct 10  2009 src
#clean发现target/目录没了

4.项目打包命令mvn package
[root@lb02 hello-world]# mvn package
[root@lb02 hello-world]# cd target/
[root@lb02 target]# ll

5.由于之前mvn clean清除了target/、现在重新生成包
[root@jenkins hello-world]# mvn package
[root@jenkins hello-world]# ll
total 4
-rw-r--r-- 1 root root 1683 Aug 26  2010 pom.xml
drwxr-xr-x 4 root root   30 Oct 10  2009 src
drwxr-xr-x 7 root root  188 Nov 21 23:58 target
[root@jenkins hello-world]# 



6.测试命令，执行src/test/java目录下的测试用例
[root@lb02 hello-world]# mvn test

5.模块安装，将打包好的jar/war文件复制到本地仓库（/root/.m2）
[root@lb02 hello-world]# mvn install

# 重点输出的信息
[INFO] Installing /opt/持续集成新版本课程/hello-world/target/hello-world-1.0-SNAPSHOT.jar to /root/.m2/repository/com/juvenxu/mvnbook/hello-world/1.0-SNAPSHOT/hello-world-1.0-SNAPSHOT.jar
[INFO] Installing /opt/持续集成新版本课程/hello-world/pom.xml to /root/.m2/repository/com/juvenxu/mvnbook/hello-world/1.0-SNAPSHOT/hello-world-1.0-SNAPSHOT.pom

[root@jenkins ~]# cd .m2/repository/com/juvenxu/mvnbook/hello-world/1.0-SNAPSHOT/
[root@jenkins 1.0-SNAPSHOT]# ll
total 16
-rw-r--r-- 1 root root 3132 Nov 22 00:00 hello-world-1.0-SNAPSHOT.jar		#最终生成这个jar包
-rw-r--r-- 1 root root 1683 Aug 26  2010 hello-world-1.0-SNAPSHOT.pom
-rw-r--r-- 1 root root  710 Nov 22 00:01 maven-metadata-local.xml
-rw-r--r-- 1 root root  195 Nov 22 00:01 _remote.repositories

```





### 在gitlab创建maven仓库

```shell
1.添加maven仓库
```

![image-20201121162623214](notes/image-20201121162623214.png)

```shell
2.将相关文件上传到仓库
[root@jenkins helloword]# ls
pom.xml  src

git add .
git commit -m 'commit maven'
git push -u origin master
```

![image-20201121170051769](notes/image-20201121170051769.png)



### 在jenkins创建maven项目

```shell
1.添加maven项目.
```

![image-20201121162305710](notes/image-20201121162305710.png)



![image-20201121163755012](notes/image-20201121163755012.png)



![image-20201121170316676](notes/image-20201121170316676.png)

保存即可

```shell
2.配置maven
```

![image-20201121170737418](notes/image-20201121170737418.png)

保存即可

```shell
3.立即构建
```



![image-20201121170754844](notes/image-20201121170754844.png)



构建完成

![image-20201121170242133](notes/image-20201121170242133.png)



```shell
4.查看构建后的产物
```

![image-20201121171109595](notes/image-20201121171109595.png)

```shell

java项目的部署流程：

部署好java环境、安装tomcat、jdk、mysql、运维从远程仓库获取java的war包、将war包放到tomcat的wabapp目录下；然后运行tomcat、mysql等服务。最终用户能够访问网站即可，war包里面包含jar包、一般由开发人员打将整个war包打好、传到仓库、我们下载基于可以使用。
```



### 10.37、手动打war包

#### 修改maven配置

```shell
vim /usr/local/maven/conf/settings.xml
找到159行，添加
    <mirror>
      <id>alimaven</id>
      <name>aliyun maven.</name>
      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
      <mirrorOf>central</mirrorOf>
    </mirror>
```

#### 手动编译代码为war包

```shell
1.修改打war的配置
[root@lb02 hello-world]# mvn package -Dmaven.test.skip=true

#修改打什么包、就什么格式
 11   <packaging>war</packaging>

#这里是定义关于打war包的插件
 30           <plugin>
 31             <artifactId>maven-war-plugin</artifactId>
 32             <version>3.2.0</version>
 33             <configuration>
 34               <failOnMissingWebXml>false</failOnMissingWebXml>
 35             </configuration>
 36          </plugin>



2.打war包

[root@jenkins hello-world]# mvn package

[INFO] Building war: /root/hello-world/target/hello-world-1.0-SNAPSHOT.war
[INFO] 
[INFO] --- maven-shade-plugin:1.2.1:shade (default) @ hello-world ---
[INFO] Replacing original artifact with shaded artifact.
[INFO] Replacing /root/hello-world/target/hello-world-1.0-SNAPSHOT.war with /root/hello-world/target/hello-world-1.0-SNAPSHOT-shaded.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 05:00 min
[INFO] Finished at: 2020-11-22T05:11:47+08:00
[INFO] Final Memory: 20M/180M
[INFO] ------------------------------------------------------------------------


3.查看生成的war包
[root@jenkins hello-world]# cd target/
[root@jenkins target]# ll
total 8
drwxr-xr-x 3 root root   17 Nov 22 05:07 classes
drwxr-xr-x 4 root root   37 Nov 22 05:11 hello-world-1.0-SNAPSHOT
-rw-r--r-- 1 root root 3561 Nov 22 05:11 hello-world-1.0-SNAPSHOT.war
drwxr-xr-x 2 root root   28 Nov 22 05:11 maven-archiver
drwxr-xr-x 3 root root   35 Nov 22 05:07 maven-status
-rw-r--r-- 1 root root 2909 Nov 22 05:11 original-hello-world-1.0-SNAPSHOT.war
drwxr-xr-x 2 root root  125 Nov 22 05:07 surefire-reports
drwxr-xr-x 3 root root   17 Nov 22 05:07 test-classes
```

