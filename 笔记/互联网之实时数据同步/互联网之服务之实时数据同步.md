---
typora-root-url: D:\notes
---

## 六、互联网之服务之实时数据同步

### **6.1rsync服务的介绍**

**【Rsync服务概念特性】**

Rsync是一款开源的、快速的、多功能的、可实现`全量及增量`的本地或远程数据同步备份的优秀工具。并且可以不进行改变原有数据的属性信息，实现数据的备份迁移特性。Rsync软件适用于unix/linux/windows等多种操作系统平台。 Rsync是一个快速和非常通用的文件复制工具。它能本地复制，远程复制，或者远程守护进程方式复制。它提供了大量的参数来控制其行为的各个方面，并且允许非常灵活的方式来实现文件的传输复制。它以其delta-transfer算法闻名。减少通过网络数据发送数量，利用只发送源文件和目标文件之间的差异信息，从而实现数据的增量同步复制。

Rsync被广泛用于数据备份和镜像

，并且作为一种改进后的复制命令用于日常运维。

Rsync具备使本地和远程两台主机之间的`数据快速复制`，`远程备份的功能`，Rsync命令本身即可实现`异地主机复制数据`，功能类似scp又优于scp，scp每次都是`全量备份`，rsync可以实现`增量拷贝`（和scp一样都是基于ssh服务传输），Rsync软件还支持配置守护进程，实现异机数据复制。

增量复制是Rsync一特点，优于scp,cp命令。

*Rsync实现如下功能*

- 本地数据同步复制，效果如cp
- 远程数据同步复制，如scp
- 本地数据删除，如rm
- 远程数据查看，如ls

*Rsync软件特性*

- 支持拷贝普通文件，特殊文件（link文件，设备文件）
- 支持排除指定文件、目录的同步功能（同步数据时，指定文件不同步）
- 能够保持原有文件所有属性均不变（stat查看的状态）
- 实现增量复制（只复制变化的数据，数据传输效率极高）
- 可以配合ssh、rcp、rsh等方式进行隧道加密文件传输（rsync本身不加密数据）
- 可以通过socket（进行通信文件）传输文件和数据（c/s架构）
- 支持匿名用户模式传输



### **6.2增量传输**

<img src="/../../notes/微信图片_20201011210328-1603868800431.png" style="zoom:50%;" />



Rsync软件的增量备份是一大特点，在备份复制数据时，Rsync通过其quick cheek算法，仅复制文件（容量、最后修改时间变化）的文件或是目录，也可以指定文件权限的变化复制，甚至可以复制一个文件里仅变化的内容，因此可以实现快速的备份复制数据。

Rsync在centos7系统上默认是3.x版本，效率更高，原理是一边比对差异，一边对差异的数据进行复制，比centos6上的Rsync 2.x更高效。

```shell
查看rsync版本
[root@chaogelinux ~]# rsync --version
rsync  version 3.1.2  protocol version 31

yum install rsync -y
```



### **6.3rsync语法**

```shell
Rsync命令参数详解

在对rsync服务器配置结束以后，下一步就需要在客户端发出rsync命令来实现将服务器端的文件备份到客户端来。rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。Rsync的命令格式可以为以下六种：

　　rsync [OPTION]... SRC DEST
　　rsync [OPTION]... SRC [USER@]HOST:DEST
　　rsync [OPTION]... [USER@]HOST:SRC DEST
　　rsync [OPTION]... [USER@]HOST::SRC DEST
　　rsync [OPTION]... SRC [USER@]HOST::DEST
　　rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
　　对应于以上六种命令格式，rsync有六种不同的工作模式：
　　1)拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号":"分隔符时就启动这种工作模式。如：rsync -a /data /backup
　　2)使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号":"分隔符时启动该模式。如：rsync -avz *.c foo:src
　　3)使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号":"分隔符时启动该模式。如：rsync -avz foo:src/bar /data
　　4)从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含"::"分隔符时启动该模式。如：rsync -av root@172.16.78.192::www /databack
　　5)从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含"::"分隔符时启动该模式。如：rsync -av /databack root@172.16.78.192::www
    6)列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://172.16.78.192/www

rsync参数的具体解释如下：

-v, --verbose 详细模式输出
-q, --quiet 精简输出模式
-c, --checksum 打开校验开关，强制对文件传输进行校验
-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD
-r, --recursive 对子目录以递归模式处理
-R, --relative 使用相对路径信息
-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。
--backup-dir 将备份文件(如~filename)存放在在目录下。
-suffix=SUFFIX 定义备份文件前缀
-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)
-l, --links 保留软链结
-L, --copy-links 想对待常规文件一样处理软链结
--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结
--safe-links 忽略指向SRC路径目录树以外的链结
-H, --hard-links 保留硬链结     -p, --perms 保持文件权限
-o, --owner 保持文件属主信息     -g, --group 保持文件属组信息
-D, --devices 保持设备文件信息    -t, --times 保持文件时间信息
-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间
-n, --dry-run现实哪些文件将被传输
-W, --whole-file 拷贝文件，不进行增量检测
-x, --one-file-system 不要跨越文件系统边界
-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节
-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步
--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息
-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件
--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件
--delete 删除那些DST中SRC没有的文件
--delete-excluded 同样删除接收端那些被该选项指定排除的文件
--delete-after 传输结束以后再删除
--ignore-errors 及时出现IO错误也进行删除
--max-delete=NUM 最多删除NUM个文件
--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输
--force 强制删除目录，即使不为空
--numeric-ids 不将数字的用户和组ID匹配为用户名和组名
--timeout=TIME IP超时时间，单位为秒
-I, --ignore-times 不跳过那些有同样的时间和长度的文件
--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间
--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0
-T --temp-dir=DIR 在DIR中创建临时文件
--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份
-P 等同于 --partial
--progress 显示备份过程
-z, --compress 对备份的文件在传输时进行压缩处理
--exclude=PATTERN 指定排除不需要传输的文件模式
--include=PATTERN 指定不排除而需要传输的文件模式
--exclude-from=FILE 排除FILE中指定模式的文件
--include-from=FILE 不排除FILE指定模式匹配的文件
--version 打印版本信息
--address 绑定到特定的地址
--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件
--port=PORT 指定其他的rsync服务端口
--blocking-io 对远程shell使用阻塞IO
-stats 给出某些文件的传输状态
--progress 在传输时现实传输过程
--log-format=formAT 指定日志文件格式
--password-file=FILE 从FILE中得到密码
--bwlimit=KBPS 限制I/O带宽，KBytes per second      
-h, --help 显示帮助信息
```



### **6.4rsync的工作方式**

scp：数据远程传输

scp 语法

scp 源文件src   目标文件dest

```shell
a:192.168.37.134
b:192.168.37.135

#a传输数据到b
scp root@192.168.37.134:/opt/test.txt root@192.168.37.200:/tmp

作为发送者:源文件为本地、目的地为37.200

#a接收b的数据
scp  root@192.168.37.200:/22.txt /

作为接收者：源文件为37.200端、目标文件为本地 
```



1本地数据传输

类似cp的复制，实现文件，目录的增量复制。

2.远程Shell数据传输

借助SSH服务在两台服务器之间传输，没有客户端/服务端之分，两台机器是相对的复制关系。

#### **6.4.1rsync本地数据传输**

【本地数据传输】

*语法模式*

```shell
rsync命令  参数   src源文件/目录    dest目标文件/目录
```

1.本地文件复制

```shell
# 复制hosts文件
[root@localhost hha]# rsync /etc/hosts /tmp/hha/
[root@localhost hha]# ls
hosts
[root@localhost hha]# cat hosts 
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain
192.168.0.200 www.dnf.com
192.168.0.201 www.cf.com
192.168.0.202 www.lol.com
```

2.复制目录内容

-r, --recursive 对子目录以递归模式处理

```shell
[root@localhost hha]# mkdir -p  /rsync/xi/haha/
[root@localhost hha]# touch /rsync/xi/haha/chaochao{1..5}.txt
[root@localhost hha]# tree /rsync/
/rsync/
└── xi
    └── haha
        ├── chaochao1.txt
        ├── chaochao2.txt
        ├── chaochao3.txt
        ├── chaochao4.txt
        └── chaochao5.txt

# 复制/data下所有内容到/tmp
rsync -r /data/ /tmp/

# 复制/data整个文件夹到/tmp
rsync -r /data  /tmp   

注意如上的区别
```

3.删除文件夹数据，使用参数--delete

--delete 删除那些DST中SRC没有的文件

```shell
[root@localhost aa]# ls
chaoge.txt  syh.txt
[root@localhost aa]# ls /ss
chaoge.txt
#将aa目录下的内容同步删除至和ss目录下一样
[root@localhost aa]# rsync -r --delete /ss/ /aa/
[root@localhost aa]# ls /aa/
chaoge.txt
[root@localhost aa]# ls /ss/
chaoge.txt

```

4.清空文件内容，使用参数--delete，参数--delete必须和-r结合用

```shell
[root@localhost aa]# cat /ss/chaoge.txt 					chaoge.txt文件是空的
[root@localhost aa]# echo "hello">/aa/syh.txt 
[root@localhost aa]# cat /aa/syh.txt 
hello														#syh.txt文件存在内容	
将syh.txt文件同步chaoge.txt删除、变为空白文件
[root@localhost aa]# rsync -r --delete /ss/chaoge.txt  /aa/syh.txt	
[root@localhost aa]# cat /aa/syh.txt 
[root@localhost aa]# cat /ss/chaoge.txt 

```



5.查询文件和目录信息，如同ls -l

```shell
1.查询文件、文件夹信息
[root@chaogelinux ~]# rsync /etc/hosts
-rw-r--r--            248 2020/03/05 15:47:44 hosts
[root@chaogelinux ~]# rsync /opt
drwxr-xr-x          4,096 2020/03/08 17:17:55 opt
```

#### **6.4.2rsync远程数据传输**

【远程数据传输】

远程传输分为两种情况【拉取|推送】

拉取：远端服务器数据，拉取到本地

推送：本地数据发送给远程服务器

*拉取pull*

```shell
语法
rsync  option               user@host:src                   dest
命令        可选参数        用户名@主机ip:源路径            本地路径
```

*推送push*

```shell
语法
rsync        option        src            user@host:dest
命令        参数            本地路径        用户@主机ip:目的路径
```

<img src="image-20200308174234172.png" style="zoom:50%;" />

1.拉取远程主机文件，拷贝到本地

```shell
#1.把远程主机的/etc/hosts文件，拷贝到本地/tmp
rsync -av -e 'ssh -p 22' root@123.206.16.61:/etc/hosts  /tmp
-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步，若是默认22，可以不写该参数
-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性
-v, --verbose 详细模式输出

[root@webserver tmp]# rsync  -av -e 'ssh -p 22' root@192.168.37.202:/etc/hosts /tmp
#执行结果
The authenticity of host '192.168.37.202 (192.168.37.202)' can't be established.
ECDSA key fingerprint is SHA256:V1N5QXThPvUvajHCCH+ov7EdfJ39qxHNMlc/LpR8Fww.
ECDSA key fingerprint is MD5:b0:a8:af:61:0c:46:4e:0d:90:d5:b6:b8:31:c2:82:35.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.37.202' (ECDSA) to the list of known hosts.
root@192.168.37.202's password: 
receiving incremental file list
hosts

sent 43 bytes  received 243 bytes  27.24 bytes/sec
total size is 158  speedup is 0.55
[root@webserver tmp]# ls
hosts  ks-script-GMhIaa  systemd-private-7753226fab734162911e7fd5d2162077-chronyd.service-dYsHjD  vmware-root  yum.log


```

2.把本地的/etc/hosts文件推送到远程服务器的/tmp下

```shell
[root@webserver tmp]# rsync -av /etc/hosts  root@192.168.37.202:/tmp
root@192.168.37.202's password: 
sending incremental file list
hosts

sent 243 bytes  received 35 bytes  50.55 bytes/sec
total size is 158  speedup is 0.57


[root@rsync ~]# ls /tmp
hosts  ks-script-SLl2JV  systemd-private-b4bc48eae30942229532b0d1d73fc1c7-chronyd.service-Go73Qz  vmware-root  yum.log
```

#### **6.4.3rsync守护进程数据传输**

【守护进程传输模式】

守护进程传输模式是在客户端和服务端之间进行的数据复制。

服务端需要配置守护进程，在客户端执行命令，实现数据`拉取`和`推送`。

语法参数

【拉取语法】

```shell
1.拉取模式语法，推荐使用，看清楚参数的符号！
rsync        参数        user@host::src        dest

2.拉取第二种
rsync        参数        rsync://user@host:port/src
```

【推送语法】

```shell
1.推送语法
rsync  参数  源路径    user@host::dest

2.推送第二种
rsync  参数  src    rsync://user@host:port/dest
```

通过语法可知，拉取和推送数据的语法几乎是相同的

想要通过守护传输模式进行复制传输数据，还得额外部署Rsync Daemon服务才行



【守护进程实战】

环境准备

准备三台服务器

```shell
1.准备3台linux机器

老师机器的环境
192.168.37.200 web-server 		 Nginx web服务器
192.168.37.202 rsync			Rsync备份存储服务器
192.168.37.201 nfs-server        NFS存储服务器
```

【环境部署，Rsync备份服务器】

```shell
1.准备linux系统环境  
#查看系统版本
[root@webserver /]# cat /etc/redhat-release
CentOS Linux release 7.5.1804 (Core) 

2.#查看内核版本
[root@rsync ~]# uname -r
3.10.0-862.el7.x86_64


3.是否安装了rsync软件，若是未安装可以yum安装即可 
[root@rsync ~]# rpm -qa rsync
rsync-3.1.2-10.el7.x86_64

```



【配置需求】

在Rsync备份机器上以rsync守护进程的方式部署Rsync服务，使得所有Rsync节点的客户端主机，可以把本地数据通过rsync命令备份数据到BACKUP服务器上。

【备份架构拓扑图】

以Rsync守护进程模式部署架构，并且以远程数据同步方式由客户端节点向服务器端推送数据

<img src="/../../notes/image-20200311102610471-1603868855916.png" style="zoom:50%;" />

Rsync守护进程客户端访问原理图

![](/../../notes/image-20200311143704499-1603868872777.png)

**Rsync服务端部署一**

| 步骤 | 举例                                     | Rsync步骤                                       |
| ---- | ---------------------------------------- | ----------------------------------------------- |
| 1    | 确认是否有个房间可以当做仓库             | 确认Rsync程序是否安装                           |
| 2    | 装修改造房间为仓库                       | 修改Rsync配置文件信息                           |
| 3    | 确认仓库的管理员                         | 创建负责Rsync服务的虚拟用户                     |
| 4    | 仓库中有柜子可以存储，管理员可以打开柜子 | 创建Rsync服务备份数据的目录，进行对虚拟用户授权 |
| 5    | 仓库要提升安全，上个锁                   | 配置Rsync服务安全相关密钥，且对密钥文件授权600  |
| 6    | 确认仓库可以用了                         | 启动Rsync服务，让其可以工作                     |
| 7    | 确定仓库每天开门工作                     | 设置Rsync服务开机启动                           |

【第一步，修改rsyncd.conf配置文件】

Rsync守护进程配置在BACKUP服务器上

```shell
1.确认安装rsync服务
yum install rsync -y 

2.修改配置文件，默认是 /etc/rsyncd.conf
写入如下参数

uid = rsync
gid = rsync
fake super = yes 
use chroot = no
max connections = 200
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsyncd.log
ignore errors
read only = false
list = false
hosts allow = 192.168.37.0/24
hosts deny = 0.0.0.0/32
auth users = rsync_backup
secrets file = /etc/rsync.password    


[backup]
comment = this is syh backup!
path = /backup
```

【rsyncd.conf参数解释】

| **配置参数**                    | **参数说明**                                                 |
| ------------------------------- | ------------------------------------------------------------ |
| uid = rsync                     | 指定rsync服务运行的时候，向磁盘进行读取和写入操作的操作者    |
| gid = rsync                     | 指定rsync服务运行的时候，向磁盘进行读取和写入操作的操作者    |
| use chroot = no                 | 进行数据同步存储时，安全相关参数，默认内网进行数据同步，可以关闭 |
| max connections = 200           | 定义向备份服务器进行数据存储的并发连接数                     |
| timeout = 300                   | 定义与备份服务器建立的网络连接，在多长时间没有数据传输时，就释放连接 |
| pid file = /var/run/rsyncd.pid  | 服务程序运行时，会将进程的pid信息存储到一个指定的pid文件中   |
| lock file = /var/run/rsync.lock | 定义锁文件，主要用于配合max connections 参数，当达到最大连接就禁止继续访问 |

| **配置参数**                   | **参数说明**                                                 |
| ------------------------------ | ------------------------------------------------------------ |
| log file = /var/log/rsyncd.log | 定义服务的日志文件保存路径信息                               |
| [backup]                       | 指定备份目录的模块名称信息                                   |
| path = /backup                 | 指定数据进行备份的目录信息                                   |
| ignore errors                  | 在进行数据备份传输过程过程中，忽略一些I/O产生的传输错误      |
| read only = false              | 设置对备份的目录的具有读写权限，即将只读模式进行关闭         |
| list = false                   | 确认是否可以将服务配置的模块信息，在客户端可以查看显示       |
| hosts allow = 172.16.1.0/24    | 设置备份目录允许进行网络数据备份的主机地址或网段信息，即设置白名单 |

| **配置参数**                       | **参数说明**                                                 |
| ---------------------------------- | ------------------------------------------------------------ |
| hosts deny = 0.0.0.0/32            | 设置备份目录禁止进行网络数据备份的主机地址或网段信息，即设置黑名单 |
| auth users = rsync_backup          | 指定访问备份数据目录的认证用户信息，为虚拟定义的用户，不需要进行创建 |
| secrets file = /etc/rsync.password | 设置访问备份数据目录进行认证用户的密码文件信息，会在文件中设置认证用户密码信息 |

| 配置参数     | 参数说明                                                     |
| ------------ | ------------------------------------------------------------ |
| [backup]     | 指定模块名称，便于日后维护                                   |
| path=/backup | 在当前模块中，Daemon使用的文件系统或目录，注意目录权限和配置文件权限一直，防止读写出问题 |
| `#exclude=`  | 排除文件或目录，相对路径                                     |
| [chaoge]     | 还可以添加其他模块                                           |

#### **6.4.4rsync远程守护之服务端配置**

**Rsync服务端配置二**

【配置数据备份的目录】

```shell
1.根据rsyncd.conf中定义的目录，创建目录、用户
[root@rsync ~]# useradd -s /sbin/nologin -M rsync
-s:设置禁止登录
-M：创建用户家目录
[root@rsync ~]# id rsync
uid=1000(rsync) gid=1000(rsync) 组=1000(rsync)

#创建目录、并设置属主、属组为rsync
[root@rsync ~]# mkdir -p /backup
[root@rsync /]# chown rsync.rsync /backup/
[root@rsync /]# ll -d /backup/
drwxr-xr-x. 2 rsync rsync 6 10月 12 20:00 /backup/



2.配置用于Rsync复制的账户、密码、文件权限，在Rsync备份服务端创建
#添加密码到文件
[root@rsync ~]# echo "rsync_backup:syh" > /etc/rsync.password
[root@rsync ~]# cat /etc/rsync.password
rsync_backup:syh



3.给密码文件设置权限
[root@rsync ~]# chmod 600 /etc/rsync.password 
[root@rsync ~]# ll /etc/rsync.password 
-rw-------. 1 root root 17 10月 12 19:56 /etc/rsync.password

4.启动rsync服务，开机自启
systemc    start rsyncd
systemc    enable rsyncd
systemc    status rsyncd

5.检查Rsync服务进程、端口
[root@rsync /]# netstat -tunpl|grep rsync
tcp        0      0 0.0.0.0:873             0.0.0.0:*               LISTEN      16925/rsync         
tcp6       0      0 :::873                  :::*                    LISTEN      16925/rsync         
[root@rsync /]# ps -ef|grep rsync
root      16925      1  0 20:08 ?        00:00:00 /usr/bin/rsync --daemon --no-detach
root      16948  16830  0 20:09 pts/1    00:00:00 grep --color=auto rsync

```

#### **6.4.5rsync远程守护之客户端配置**

Rsync客户端(nfs-server)配置

```shell
1.确认rsync命令是否有
2.创建和rsync服务端连接的账户密码文件，且授权
3.注意Rsync客户端要和服务端的配置区别开
```



配置过程

```shell
1.安装rsync
yum install rsync -y

2.创建密码文件，和服务端相同
[root@nfs etc]# echo "syh">/etc/rsync.password
[root@nfs etc]# cat rsync.password 
syh


3.给密码文件设置权限
[root@nfs etc]# chmod 600 /etc/rsync.password
[root@nfs etc]# ll /etc/rsync.password
-rw-------. 1 root root 4 10月 12 20:15 /etc/rsync.password


4.配置特殊变量RSYNC_PASSWORD，可以替代密码文件

export RSYNC_PASSWORD=syh   #临时生效
#永久生效
[root@nfs etc]# echo "export RSYNC_PASSWORD=syh" >> /etc/bashrc
[root@nfs etc]# tail -1 /etc/bashrc
export RSYNC_PASSWORD=syh


5.验证密码以及密码变量
root@nfs etc]# echo $RSYNC_PASSWORD
syh
[root@nfs etc]# tail -1 /etc/bashrc
export RSYNC_PASSWORD=syh

```

至此Rsync守护进程方式，服务端、客户端都配置完毕



【测试数据同步】

推送：客户端同步文件给服务端

```shell
1.从本地客户端将/opt下的所有内容发送到rsync服务端的/backup下
[root@nfs /]# rsync -avzP /opt/ rsync_backup@192.168.37.202::backup --password-file=/etc/rsync.password

[root@rsync backup]# ls
syh10.txt  syh12.txt  syh14.txt  syh16.txt  syh18.txt  syh1.txt   syh2.txt  syh4.txt  syh6.txt  syh8.txt
syh11.txt  syh13.txt  syh15.txt  syh17.txt  syh19.txt  syh20.txt  syh3.txt  syh5.txt  syh7.txt  syh9.txt


2.(将本地客户端的/tmp整个文件夹推送到rsync服务端的/backup下)；配置了密码变量、则可以不写 --password-file=/etc/rsync.password

[root@nfs tmp]# rsync -avzP /tmp rsync_backup@192.168.37.202::backup 
[root@rsync backup]# ls
syh10.txt  syh12.txt  syh14.txt  syh16.txt  syh18.txt  syh1.txt   syh2.txt  syh4.txt  syh6.txt  syh8.txt  tmp
syh11.txt  syh13.txt  syh15.txt  syh17.txt  syh19.txt  syh20.txt  syh3.txt  syh5.txt  syh7.txt  syh9.txt
```

【客户端推送命令解释】

```shell
 rsync -avzP /data/ rsync_backup@192.168.37.202::backup --password-file=/etc/rsync.password
 -avzP /opt
-a  保持文件原有属性
-v    显示传输细节情况
-z    对传输数据压缩传输
-P    显示文件传输的进度信息
/opt  要推送的本地目录，注意/opt/ 表示推送该目录下内容



选项解释
rsync_backup@192.168.37.202::backup --password-file=/etc/rsync.password

rsync_backup: rsync同步数据的虚拟认证用户、# 验证rsync服务端参数 grep 'auth user' /etc/rsyncd.conf
@192.168.37.20:2：#要推送的目的地ip地址以及模块名称
backup:# 是rsync服务端配置文件中定义的模块名  /etc/rsyncd.conf 
--password-file=/etc/rsync.password: #指定密码文件

```



拉取：从服务器端同步文件或目录到客户端

把rsync服务端的备份目录中的数据，拷贝到客户端的某个目录

```shell
1.在客户端执行
[root@nfs /]# rsync -azv rsync_backup@192.168.37.202::backup /rsync_back/
receiving incremental file list
./
af.txt
cha.sh

sent 65 bytes  received 157 bytes  444.00 bytes/sec
total size is 0  speedup is 0.00


2.此时也就吧rsync服务端的/backup目录下的内容，同步到客户端的/rsync_back/目录下了
[root@nfs /]# ls /rsync_back/
af.txt  cha.sh
```



**注意同步问题**

【客户端的错误现象：No route to host】

```shell
[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

rsync: failed to connect to 172.16.1.41: No route to host (113)

rsync error: error in socket IO (code 10) at clientserver.c(124) [sender=3.0.6]
```

解决办法：

```shell
1.关闭iptables，或者添加规则
iptables -F
systemctl stop firewalld

2.关闭selinux
[root@nfs01 ~]# setenforce 0  #临时关闭
[root@rsync01 ~]# sed -i 's/enforcing/disabled/g' /etc/selinux/config  #重启永久关闭
```



#### **6.4.6rsync同步传输常见问题**

【注意命令同步的细节】

```shell
1.同步整个文件夹
[root@nfs01 ~]# rsync -avzP /etc rsync_backup@192.168.178.139::backup

2.同步文件夹下内容
[root@nfs01 ~]# rsync -avzP /etc/ rsync_backup@192.168.178.139::backup
```

【ERROR: The remote path must start with a module name not a /】

```shell
rsync客户端执行rsync命令错误：

客户端的错误现象：  

[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::/backup

ERROR: The remote path must start with a module name not a /

rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]
```

办法

```shell
原因：客户端命令敲错了
rsync命令语法理解错误，::/backup是错误的语法，应该为::backup(rsync模块)
```





【@ERROR: auth failed on module backup】

```shell
客户端的错误现象：

[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

Password:

@ERROR: auth failed on module backup

rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]
```

【@ERROR: auth failed on module backup】

```shell
客户端的错误现象：

[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

Password:

@ERROR: auth failed on module backup

rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]
```

办法

```shell
1.密码文件错误/etc/rsync.password
2.密码文件参数和实际的密码文件名不一致，检查secrets file = /etc/rsync.password
3.密码文件权限不对 ll /etc/rsync.password  不是600
4.检查免密文件，是否手误
[root@rsync01 ~]# cat /etc/rsync.password
rsync_backup:chaoge

5.rsync客户端的密码文件写错，只需要写入密码即可
[root@nfs01 ~]# cat /etc/rsync.password
chaoge
```

【@ERROR: Unknown module 'backup'】

方法：

```
异常问题解决：

1、 /etc/rsyncd.conf配置文件模块名称书写错误

2、配置文件中网段限制不对
```

【Permission denied】

```shell
[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

Password:

sending incremental file list

hosts

rsync: mkstemp ".hosts.5z3AOA" (in backup) failed: Permission denied (13)

sent 196 bytes  received 27 bytes  63.71 bytes/sec

total size is 349  speedup is 1.57

rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1039) [sender=3.0.6]
```

办法

```shell
1. 共享目录的属主和属组不正确，不是rsync

2. 共享目录的权限不正确，不是755

3.注意防火墙，selinux的关闭
```

【chdir failed 】

```shell
[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

Password:

@ERROR: chdir failed

rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]
```

方法

```shell
异常问题解决：

1. 备份存储目录没有建立

2. 建立的备份存储目录和配置文件定义不一致
```

【invalid uid rsync】

```shell
[root@nfs01 tmp]# rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

Password:

@ERROR: invalid uid rsync

rsync error: error starting client-server protocol (code 5) at main.c(1503) [sender=3.0.6]
```

办法

```shell
异常问题解决：

rsync服务对应rsync虚拟用户不存在了
```

【客户端有/etc/rsync.password依旧需要输入密码】

```shell
1.密码文件也得是600权限
2.密码文件名字是否正常
```

【Connection refused (111)】

```shell
[root@oldboy-muban ~]#  rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup

rsync: failed to connect to 172.16.1.41: Connection refused (111)

rsync error: error in socket IO (code 10) at clientserver.c(124) [sender=3.0.6]
```

办法

```shell
1.检查防火墙，selinux的关闭
2.检查rsync服务端rsyncd是否开启
```

**Rsync服务端排错思路**

1. 检查rsync服务端的配置文件路径是否正确：`/etc/rsyncd.conf`
2. 查看配置文件的`host allow`,`host deny`允许的ip网段是否允许客户端访问
3. 查看配置文件中的path参数路径是否存在，权限是否正确（和配置文件的UUID参数对应）
4. 查看rsync服务是否启动，端口、进程是否存活
5. 查看iptables防火墙、selinux是否允许rsync服务通过，或是关闭
6. 查看服务端rsync配置文件的密码文件，权限是否600，格式，语法是否正确，且和配置文件的`secrect files`参数对应
7. 如果是推送数据，要查看配置rsyncd.conf中的用户对该`rsync模块`下的文件是否可以读取

**Rsync客户端排错**

1. 查看rsync客户端配置的密码文件权限是否600，密码文件格式是否正确，是否和服务端的密码一致
2. 尝试telnet连接rsync服务端的`873`端口，检测服务是否可以连接
3. 客户端执行命令语法要检查，细心



### **6.5rsync多模块扩展功能**



前文都是访问单个的rsync模块，访问同步的目录/backup，rsync支持同时从其他目录拉取资料呢？当然可以

【修改rsyncd.conf配置多模块】

```shell
1.打开rsyncd.conf配置文件
[root@rsync ~]# vim /etc/rsyncd.conf 
uid = rsync
gid = rsync
fake super = yes
use chroot = no
max connections = 200
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsyncd.log
ignore errors
read only = false
list = false
hosts allow = 192.168.37.0/24
hosts deny = 0.0.0.0/32
auth users = rsync_backup
secrets file = /etc/rsync.password

[backup]
comment = this is syh backup!
path = /backup


[mydate]
path = /mydata

```

2.创建mydata模块下指定的目录且授权

```shell
[root@rsync /]# mkdir -p /mydata
[root@rsync /]# chown - R rsync.rsync /mydata/
[root@rsync /]# ls -ld /mydata/
drwxr-xr-x 2 rsync rsync 6 10月 13 12:23 /mydata/
```

3.重启rsync服务

```shell
[root@rsync /]# systemctl restart rsyncd
[root@rsync /]# systemctl status rsyncd
```

4.客户端同步测试

客户端服务端推送数据给服务端

```shell
[root@nfs rsync_back]# rsync -azvP /rsync_back/af.txt  rsync_backup@192.168.37.202::mydata
sending incremental file list
af.txt
              0 100%    0.00kB/s    0:00:00 (xfr#1, to-chk=0/1)

sent 85 bytes  received 35 bytes  240.00 bytes/sec
total size is 0  speedup is 0.00

```

5.回到服务端查找

```shell
[root@rsync mydata]# ls /mydata/
af.txt
```

【排除指定目录和文件数据复制】

1.准备好Rsync服务端工作

```shell
1.准备好测试的文件夹目录
cd /backup/
mkdir {a..d}
touch a/1 b/2 c/3 d/4

yum install tree -y

# 备份目录下有如下文件
[root@rsync01 backup]# tree
[root@rsync backup]# tree /backup/
/backup/
├── a
│   └── 1
├── af.txt	#原有数据
├── b
│   └── 2
├── c
│   └── 3
├── cha.sh	#原有数据
└── d
    └── 4

```

2.在客户端上拉取文件，且排除a c目录机器内部文件，以及b目录下的2文件，其他文件进行同步

```shell
--exclude=文件   # 匹配排除文件
```

```shell
1.准备好一个测试的目录，用于数据同步  
[root@nfs rsync_back]# ls /rsync_back/



2.执行同步且排除文件的命令
[root@nfs01 ~]# rsync --exclude=a --exclude=b/2  --exclude=c -avzP rsync_backup@192.168.37.202::backup /rsync_back --password-file=/etc/rsync.password

3.检查同步的文件，是否正确
[root@nfs rsync_back]# tree ./
./
├── af.txt
├── b
├── cha.sh
└── d
    └── 4
#排除了目录a、目录c以及目录b内的2文件
```

至此可以看出同步的过程以及tree命令可以清晰看出同步的文件结果

【方法二，在Rsync服务端配置】

此方式也能达到以上的排除文件或目录发送的效果

```shell
1.修改rsync服务端配置文件，添加如下配置，排除指定目录
exclude=a c b/2

2.重启服务
[root@rsync01 backup]# systemctl restart rsyncd

3.在客户端取数据并查看
[root@nfs rsync_back]# rsync -avzP rsync_backup@192.168.37.202::backup /rsync_back

[root@nfs rsync_back]# tree ./
./
├── af.txt
├── b
├── cha.sh
└── d
    └── 4

```





**【服务器之间数据无差异复制】**

【问题背景】

<img src="/../../notes/image-20200312172538549.png" alt="image-20200312172538549" style="zoom:50%;" />

【无差异复制】

<img src="/../../notes/image-20200312172756937.png" alt="image-20200312172756937" style="zoom:50%;" />





实现该同步方式，主要是使用rsync的`--delete`参数

所谓无差异复制，指的是`无论拉取，还是推送，都保持两边的数据完全一致`，也就删除其他多余文件的参数

【1.本地推送式删除】

```shell
# 保持/mnt下内容和/tmp完全一致，删除其他多余文件
[root@rsync01 tmp]# rsync -avzP --delete /tmp/  /mnt/
```

【2.拉取数据无差异同步】

注意rsyncd.conf配置文件，之前配置过`排除文件的参数`

```shell
rsync -avzP --delete rsync_backup@192.168.178.148::backup /mnt/ --password-file=/etc/rsync.password
```

**再次强调，`--delete`参数就是保证`客户端`和`服务端`的数据完全一致，这可能是个危险的命令！！**

【3.推送数据无差异同步】

**也就是将本地的目录和远程服务端的目录保持一致，使用不当可能会造成远程服务器的备份数据丢失！！小心使用**

```shell
[root@nfs01 ~]# rsync -avz  --delete /tmp/ rsync_backup@192.168.178.157::backup --password-file=/etc/rsync.password[root@nfs01 ~]# rsync -avz  --delete /tmp/ rsync_backup@192.168.178.157::backup --password-file=/etc/rsync.password
```

--delete参数总结与生产环境

- Rsync推送企业工作场景：数据备份、上传

```shell
本地有的资料，远端机器完全一致
在使用场景是备份、上传情况下，一般不用加上--delete参数，除非是NFS服务的实施复制，数据必须完全一致性
```

- Rsync拉取场景：代码发布、下载

```shell
Rsync无差异同步还可以用于负载均衡下的Web服务器之间的同步，或者NFS共享数据的同步
```

### **6.6rsync的断点续传功能**

Rsync支持大文件断点续传，参数如下

```shell
--partial  
默认情况rsync传输中断后，将会删除所有部分传输的文件，某些情况下用户希望能保留已经传输的内容，该参数告知rsync保留部分已传输的文件，可以使得剩余文件部分传输

--partial-dir=DIR
保留部分传输文件，这是个更好的参数，能够指定目录保存部分数据，而不是写入目标文件
下次传输的时候，rsync将使用该目录的数据，来恢复整体数据传输，结束后删除该目录
```

【断点续传案例】

```shell
1.在客户端快速生成1G文件
[root@nfs rsync_back]# dd if=/dev/zero of=test1  bs=10M count=128
记录了128+0 的读入
记录了128+0 的写出
1342177280字节(1.3 GB)已复制，5.58072 秒，241 MB/秒

[root@nfs rsync_back]# ls -lh ./
总用量 1.3G
-rw-r--r-- 1 root root 1.3G 10月 13 16:51 test1

2.加上断点续传指定目录参数，传输中断，部分数据也保存在了指定目录,传输结束后，会删除该文件
[root@nfs rsync_back]# rsync -azvP --partial-dir=/tmp/ /rsync_back/test1  rsync_backup@192.168.37.202::backup
sending incremental file list
test1
    466,255,872  34%  148.31MB/s    0:00:05  ^C			#ctrl+c冲断传输
rsync error: received SIGINT, SIGTERM, or SIGHUP (code 20) at rsync.c(638) [sender=3.1.2]


3.此时查看服务端的/backup目录
#生成tmp目录、
[root@rsync ~]# ls /backup/
a  af.txt  b  c  cha.sh  d  tmp
#传输了一部分数据
[root@rsync ~]# du -sh /backup/tmp/
545M	/backup/tmp/

4.继续在客户端执行刚才的传输命令
[root@nfs rsync_back]# rsync -azvP --partial-dir=/tmp/ /rsync_back/test1  rsync_backup@192.168.37.202::backup
sending incremental file list
test1
  1,342,177,280 100%  132.02MB/s    0:00:09 (xfr#1, to-chk=0/1)

sent 32,417 bytes  received 167,316 bytes  13,774.69 bytes/sec
total size is 1,342,177,280  speedup is 6,719.86

5.再次查看服务端的/backup目录
#传输完毕后tmp的断点传续文件删除
[root@rsync tmp]# ls
#发现存在test1文件
[root@rsync backup]# ls
a  af.txt  b  c  cha.sh  d  test1  tmp
[root@rsync backup]# du -sh test1 
1.3G	test1

```





**Rsync限速**

```shell
限速参数
--bwlimit=KBPS
该参数允许最大传输速率是多少KB/s，设置为0则不限速
```

在某公司，白天高峰期某DBA人员在数据库服务器通过rsync复制百G数据到备份服务器，导致数据库服务器带宽占满，造成用户无法访问。

这就应该用rsync限速功能，限制复制速度在带宽的1/3这样，就能够解决该问题

当然，尽量别在高峰期做大数据复制行为！

```shell
1.在客户端快速生成1G文件
[root@nfs rsync_back]# ls -ldh ./test1 
-rw-r--r-- 1 root root 1.3G 10月 13 16:51 ./test1


2.不限速传输形式
[root@nfs rsync_back]# rsync -azvP --partial-dir=/tmp/ /rsync_back/test1  rsync_backup@192.168.37.202::backup
sending incremental file list
test1
  1,342,177,280 100%  132.02MB/s    0:00:09 (xfr#1, to-chk=0/1)

sent 32,417 bytes  received 167,316 bytes  13,774.69 bytes/sec
total size is 1,342,177,280  speedup is 6,719.86

3.限速传输
[root@nfs rsync_back]# rsync -avzP --bwlimit=10   /rsync_back/test1   rsync_backup@192.168.37.202::backup
sending incremental file list
test1
  1,342,177,280 100%   10.54MB/s    0:02:01 (xfr#1, to-chk=0/1)

sent 1,305,345 bytes  received 35 bytes  10,158.60 bytes/sec
total size is 1,342,177,280  speedup is 1,028.19

```

【**生产经验**】

rsync默认增量复制，与oss的数据复制的时候，注意参数，无法用-a参数，因为涉及到权限问题，-a是保持属性

rsync -r



### **6.7企业级实时复制介绍**



**实时复制介绍**

网站集群架构中，数据永远是最核心且重要的，数据丢失，将会给企业造成巨大损失

【数据遭到破坏】



<img src="/../../notes/image-20200313103200974-1603868901666.png" style="zoom:50%;" />

<img src="/../../notes/image-20200313103244792 (1)-1603868904131.png" style="zoom:50%;" />



==**数据备份方案**==

企业网站和应用都得有完全的数据备份方案确保数据不丢失，通常企业有如下的数据备份方案

定时任务定期备份

需要周期性备份的数据可以分两类：

- 后台程序代码、运维配置文件修改，一般会定时任务执行脚本进行文件备份，然后配置Rsync工具推送到远程服务器备份
- 对于数据库文件用定时任务脚本配合数据库提供的备份工具，定时生成备份文件，配合Rsync备份到远端

为什么要用实时同步服务

因为定时任务有缺陷，一分钟以内的数据无法进行同步，容易造成数据丢失

==**实施复制方案**==

实施复制是最适合企业备份重要数据的方式，用于用户提交的数据备份，对于用户提交的普通文件（jpg、tar、zip、MP4、txt、html）等待，都可以用`Inofity+Sersync+Rsync`实时备份方案。

对于数据文件，还有更复杂的分布式存储方案，把数据同时备份成多份，如FastDFS、GlusterFS等

对于提交到数据库中的数据，还可以用数据库的主从复制（如MySQL），这是软件自带的实时备份。

==**图解备份方式**==

![](/../../notes/image-20200313110213125-1603868907055.png)

==图解实时复制==

![](/../../notes/image-20200315153148617-1603868909468.png)

实时复制环境准备

【部署机器准备】

```
NFS01机器  192.168.37.201       /data共享目录
BACKUP机器      192.168.37.202                                /backup 备份目录
```

**==实时复制说明==**

1.实时复制软件会监控磁盘文件系统的变化，比如指定的/data目录，实时复制软件进程会实时监控这个/data目录中对应文件系统数据的变化。

2.一旦/data目录文件发生变化，就会执行rsync命令，将变化的数据推送到备份服务器对应的备份目录中



### **6.8实时复制的软件工具介绍**

**==实施复制软件介绍==**

企业常用实时复制软件如下两款

| 软件          | 依赖程序      | 部署难点 | 说明             |
| ------------- | ------------- | -------- | ---------------- |
| Inotify-tools | Rsync守护进程 | 复制脚本 | 监控目录数据变化 |
| Sersync*      | Rsync守护进程 | 配置文件 | 监控目录数据变化 |



### **6.9实时复制的工作流**

==Inotify**机制**==

Inotify是一种异步的系统事件监控机制，通过Inotify可以监控文件系统中添加、删除、修改等事件，利用这个内核接口，第三方软件可以监控文件系统下的情况变化。

那么Inofity-tools就是该类软件的实现，是一个监控指定目录数据实时变化的软件。

实现了Inotify的软件还有`Sersync`、`Inotify-tools`

```
Sersync软件是在Inotify的基础上进行开发的，功能更加强大，支持配置文件中定义、重试机制、过滤机制、提供CDN数据更新、多线程操作等。
```

【Inotify机制的优点】

- 监控文件系统的事件变化，通过复制工具实现实时数据复制
- 支持多线程实时复制

【Inotify的缺点】

- 实测当文件数量大于200个（10~100kb），复制存在延迟。



### **6.10Inofity+tools实施复制实战**

无论是Inotify-tools还是Sersync、本身的核心功能都是`监控指定目录内的数据变化`，具体的复制到远端服务器的功能还是借助Rsync工具配合，Inotify机制软件工作流程如下

1. 备份源客户端开机运行Inotify软件，检测指定目录的文件系统变化
2. 一旦获取到指定监控目录的数据发生变化，即刻执行Rsync命令复制数据。
3. 将变化的数据发送到Rsync服务端的备份目录。





**==项目部署实施==**

【1.确保远程数据传输服务部署完成】

==**前提配置好Rsync Daemon模式**==

```
也就是可以在客户端机器，推送、拉取数据到BACKUP服务器，才能配置Inofity-tools

将rsync守护进程模式部署完毕
rsync服务端部署
a 检查rsync软件是否已经安装
b 编写rsync软件主配置文件
c 创建备份目录管理用户
d 创建备份目录，并进行授权
e 创建认证文件，编写认证用户和密码信息，设置文件权限为600
f 启动rsync守护进程服务
```

**==在NFS01机器配置==**



```shell
rsync客户端部署
a 检查rsync软件是否已经安装    
b 创建认证文件，编写认证用户密码信息即可，设置文件权限为600
c 利用客户端进行数据同步测试

当前也就是rsync客户端机器，配置如下部署
1.设置密码环境变量，方便的使用rsync命令
[root@nfs01 ~]# echo "export RSYNC_PASSWORD=chaoge"  >> /etc/bashrc


2.加载配置文件
source /etc/bashrc


3.检查环境变量
[root@nfs rsync_back]# echo $RSYNC_PASSWORD
syh


4.作为Rsync客户端，测试推送和拉取数据是否正常
#推送本地数据给Rsync服务端
[root@nfs rsync_back]# rsync -azvP /rsync_back/test.sh  rsync_backup@192.168.37.202::backup
sending incremental file list
test.sh
              0 100%    0.00kB/s    0:00:00 (xfr#1, to-chk=0/1)

sent 85 bytes  received 35 bytes  240.00 bytes/sec
total size is 0  speedup is 0.00


#查看服务端是否接收
[root@rsync backup]# ls
test.sh


5.拉取服务端资料
[root@nfs rsync_back]# rsync -azvP rsync_backup@192.168.37.202::backup/syh.txt /rsync_back/
receiving incremental file list
syh.txt
              0 100%    0.00kB/s    0:00:00 (xfr#1, to-chk=0/1)

sent 43 bytes  received 86 bytes  258.00 bytes/sec
total size is 0  speedup is 0.00

#查看客户端是否接收
[root@nfs rsync_back]# ls
syh.txt
```

**==检查Linux版本是否支持Inotify机制==**

只有Linux内核版本在2.6.13起才支持，以及是否存在三个系统文件，存在则支持



```shell
1.检查linux内核版本
[root@nfs /]# uname -r
3.10.0-862.el7.x86_64


2.检查Inotify相关文件
[root@nfs /]# ls -l /proc/sys/fs/inotify/
总用量 0
-rw-r--r-- 1 root root 0 10月 13 17:54 max_queued_events
-rw-r--r-- 1 root root 0 10月 13 17:54 max_user_instances
-rw-r--r-- 1 root root 0 10月 13 17:54 max_user_watches

max_user_watches:    设置inotifywait或inotifywatch命令可以监视的文件数量（单进程）
默认只能监控8192个文件

max_user_instances:    设置每个用户可以运行的inotifywait或inotifywatch命令的进程数
默认每个用户可以开启inotify服务128个进程

max_queued_events:    设置inotify实例事件（event）队列可容纳的事件数量
默认监控事件队列长度为16384
```



**==Inotify-tools工具安装==**

```shell
1.yum安装，需配置epel源
[root@nfs01 ~]# yum install inotify-tools -y

2.检查软件
[root@nfs01 ~]# rpm -ql inotify-tools|head -2
/usr/bin/inotifywait        # 重要软件命令
/usr/bin/inotifywatch        # 重用软件命令
```

**==Inotify命令工具==**

上述操作我们安装好了Inotify-tools软件，生成2个重要的命令

- inotifywait：在被监控的目录等待特定文件系统事件（open、close、delete等事件），执行后处于阻塞状态，适合在Shell脚本中使用，是实现监控的关键
- Inotifywatch：收集被监控的文件系统使用的统计数据（文件系统事件发生的次数统计）

==【inotifywait命令解释】==

```shell
inotifywait用于等待文件或文件集上的一个待定事件，可以监控任何文件和目录设置，并且可以递归地监控整个目录树；

inotifywatch用于收集被监控的文件系统计数据，包括每个inotify事件发生多少次等信息

从上面可知inotifywait是一个监控事件，可以配合shell脚本使用它。与它相关的参数：

语法格式：inotifywait [-hcmrq][-e][-t][–format][-timefmt][…]

-m： 即“–monitor” 表示始终保持事件监听状态。

-d：类似于-m参数，将命令运行在后台，记录出发的事件信息，记录在指定文件里，加上--outfile参数

-r： 即“–recursive” 表示递归查询目录

-q： 即“–quiet” 表示打印出监控事件

-o： 即“–outfile” 输出事情到一个文件而不是标准输出

-s: 即“–syslog” 输入错误信息到系统日志

-e： 即“–event”， 通过此参数可以指定要监控的事件，常见的事件有modify、delete、create、close_write、move、close、unmount和attrib等

-format： 指定输出格式；常用的格式符如：

%w：表示发生事件的目录

%f：表示发生事件的文件

%e：表示发生的事件

%Xe:事件以“X”分隔

%T：使用由-timefmt定义的时间格式

-timefmt：指定时间格式，用于-format选项中的%T格式
```

利用Inotify软件监控的事件主要是如下

```shell
Events    含义
access    文件或目录被读取
modify    文件或目录内容被修改
attrib    文件或目录属性被改变
close    文件或目录封闭，无论读/写模式
open    文件或目录被打开
moved_to    文件或目录被移动至另外一个目录
move    文件或目录被移动到另一个目录或从另一个目录移动至当前目录
create    文件或目录被创建在当前目录
delete    文件或目录被删除
umount    文件系统被卸载
```

**==Inotify可监控的事件==**

```shell
#可监控的事件
#有几种事件能够被监控。一些事件，比如 IN_DELETE_SELF 只适用于正在被监控的项目，而另一些，比如 IN_ATTRIB 或者 IN_OPEN 则只适用于监控过的项目，或者如果该项目是目录，则可以应用到其所包含的目录或文件。

IN_ACCESS
#被监控项目或者被监控目录中的条目被访问过。例如，一个打开的文件被读取。
IN_MODIFY
#被监控项目或者被监控目录中的条目被修改过。例如，一个打开的文件被修改。
IN_ATTRIB
#被监控项目或者被监控目录中条目的元数据被修改过。例如，时间戳或者许可被修改。
IN_CLOSE_WRITE
#一个打开的，等待写入的文件或目录被关闭。
IN_CLOSE_NOWRITE
#一个以只读方式打开的文件或目录被关闭。
IN_CLOSE
#一个掩码，可以很便捷地对前面提到的两个关闭事件（IN_CLOSE_WRITE | IN_CLOSE_NOWRITE）进行逻辑操作。
IN_OPEN
#文件或目录被打开。
IN_MOVED_FROM
#被监控项目或者被监控目录中的条目被移出监控区域。该事件还包含一个 cookie 来实现 IN_MOVED_FROM 与 IN_MOVED_TO 的关联。
IN_MOVED_TO
#文件或目录被移入监控区域。该事件包含一个针对 IN_MOVED_FROM 的 cookie。如果文件或目录只是被重命名，将能看到这两个事件，如果它只是被移入或移出非监控区域，将只能看到一个事件。如果移动或重命名一个被监控项目，监控将继续进行。参见下面的 IN_MOVE-SELF。
IN_MOVE
#可以很便捷地对前面提到的两个移动事件（IN_MOVED_FROM | IN_MOVED_TO）进行逻辑操作的掩码。
IN_CREATE
#在被监控目录中创建了子目录或文件。
IN_DELETE
#被监控目录中有子目录或文件被删除。
IN_DELETE_SELF
#被监控项目本身被删除。监控终止，并且将收到一个 IN_IGNORED 事件。
IN_MOVE_SELF
#监控项目本身被移动。
```

### **6.11inotifywait目录事件检测**





**==测试create事件==**

```shell
# 语法
inotifywait -mrq --timefmt "%F" --format "%T %w%f 事件信息：%e" /data  <-- 相对完整的命令应用


# 指定事件监控
inotifywait -mrq --timefmt "%F" --format "%T %w%f 事件信息：%e" -e create /data  

# 实际案例，监控/data目录的创建
[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %H:%M:%S' --format '%T %w %f %e' -e create /data
# 参数解释
-m： 即“–monitor” 表示始终保持事件监听状态。
-r： 即“–recursive” 表示递归查询目录
-q： 即“–quiet” 表示打印出监控事件
--timefmt：指定时间格式
%m 　月份(以01-12来表示)。
%d 　日期(以01-31来表示)。
%y 　年份(以00-99来表示)。
%H	小时(以00-23来表示)。
%M	分钟(00-59来表示)。
%S	秒数(00-59来表示)。

%w：表示发生事件的目录
%f：表示发生事件的文件
%T：使用由-timefmt定义的时间格式(第一个)
%T：指定前面的日期格式化(第一个)
%e：表示发生的事件

#日志监测

[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %H:%M:%S' --format '%T %w %f %e' -e create /data
20-10-14 11:47:06 /data/ chao CREATE,ISDIR	#创建文件夹
20-10-14 11:49:36 /data/ women.txt CREATE	#创建文件

-e： 即“–event”， 通过此参数可以指定要监控的事件，常见的事件有modify、delete、create、close_write、move、close、unmount和attrib等

```

![](notes/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201014115858.png)

【上述案例解读】

```shell
命令中只监控了create的事件，并没有检测其他事件，因此也只有create会被inotify监控到
-e： 即“–event”， 通过此参数可以指定要监控的事件，常见的事件有modify、delete、create、close_write、move、close、unmount和attrib等
```

![](/../../notes/image-20200316094403287-1603868915205.png)

****

**==【测试delete事件】==**



```shell
[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %T' --format '%T %w %f 监测的事件如下：%e' -e delete /data
20-10-14 16:16:57 /data/ stst.txt 监测的事件如下：DELETE

[root@nfs data]# rm stst.txt 
rm：是否删除普通空文件 "stst.txt"？y

```



**==【测试close_write事件】==**

close_write事件只能监测对文件的创建和修改两个事件

```shell
[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %T' --format '%T %w %f 监测的事件如下：%e' -e close_write /data
20-10-14 16:24:08 /data/ test.sh 监测的事件如下：CLOSE_WRITE,CLOSE
20-10-14 16:24:29 /data/ test.sh 监测的事件如下：CLOSE_WRITE,CLOSE


[root@nfs data]# touch test.sh
[root@nfs data]# echo '今日天气真好'> test.sh

```

inotify增删改事件

| 重要事件    | 包含事件                   | 说明                                               |
| ----------- | -------------------------- | -------------------------------------------------- |
| close       | close_write、close_nowrite | 文件或目录关闭，不管是`读`还是`写`都包含`关闭`操作 |
| close_write | create                     | 含创建文件事件，不含创建目录事件，自身有修改事件   |
| move        | moved_to、moved_from       | 文件或目录无论是移动、移除监控目录，都被监控       |

### **6.12inotify检测sed事件**

扩展：sed命令触发事件

在NFS上开启Inotify监控功能

```shell
1.检测所有事件
[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %T' --format '%T %w %f 监测的事件如下：%e'  /data

```

  ![image-20201014171316045](/../../notes/image-20201014171316045-1603868919650.png)

利用sed修改文件内容

```shell
# 替换test.sh的内容，且进行备份，旧内容在test.bak  ，替换后内容在test.sh
终端1
[root@nfs data]# sed -i 's/beijing/BEIJING/g' test.sh		将beijin替换为BEIJING


终端2
[root@nfs /]# inotifywait -mrq  --timefmt '%y-%m-%d %T' --format '%T %w %f 监测的事件如下：%e'  /data

20-10-14 17:43:45 /data/ test.sh 监测的事件如下：OPEN					打开要被修改的文件
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：CREATE					创建打开sed的临时文件
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：OPEN
20-10-14 17:43:45 /data/ test.sh 监测的事件如下：ACCESS					访问要被修改的文件
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：MODIFY				sed对临时文件进行修改
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：ATTRIB				文件属性发送变化
20-10-14 17:43:45 /data/ test.sh 监测的事件如下：CLOSE_NOWRITE,CLOSE	以只读方式打开的文件或目录被关闭	
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：CLOSE_WRITE,CLOSE	sed临时文件被关闭
20-10-14 17:43:45 /data/ test.sh 监测的事件如下：MOVED_FROM				被移除监控目录
20-10-14 17:43:45 /data/ test.sh.bak 监测的事件如下：MOVED_TO			对被修改的目录重命名
20-10-14 17:43:45 /data/ seduJzyTE 监测的事件如下：MOVED_FROM			移除sed监控的文件
20-10-14 17:43:45 /data/ test.sh 监测的事件如下：MOVED_TO				对文件重命名


# sed修改文件事件如下
1. 创建临时文件
2. 把源文件内容放入临时文件中
3. 修改临时文件内容
4. 对源文件进行备份 -i.bak ---- test.sh.bak
5. 对临时文件重命名为chaoge.txt
```

### **6.13手动实现inotify结合rsync同步**

Inotify-tools软件部署实战

手工配置inotify的监控事件，增删改查

```shell
1.检测目录的增删改查事件
[root@nfs ~]# inotifywait -mrq --timefmt '%y-%m-%d %T' --format '%T %w %f 检测事件为：%e' -e close_write,delete /data
```

再开一个终端，修改数据

```shell
终端2
[root@nfs data]# touch /data/test_inotify.txt
[root@nfs data]# echo 'hello,my name is syh'>/data/test_inotify.bak
[root@nfs data]# rm -rf /data/*

终端1
[root@nfs ~]# inotifywait -mrq --timefmt '%y-%m-%d %T' --format '%T %w %f 检测事件为：%e' -e close_write,delete /data/
20-10-14 18:46:19 /data/ test_inotify.txt 检测事件为：CLOSE_WRITE,CLOSE
20-10-14 18:46:36 /data/ test_inotify.bak 检测事件为：CLOSE_WRITE,CLOSE
20-10-14 18:46:45 /data/ test_inotify.bak 检测事件为：DELETE
20-10-14 18:46:45 /data/ test_inotify.txt 检测事件为：DELETE

```

### **6.14结合脚本实现inotify事件结合rsync同步**

**==编写实时监控和复制脚本==**



```shell
1.创建管理脚本的目录
[root@nfs /]# mkdir -p /myscripts/
[root@nfs /]# cd /myscripts/
[root@nfs myscripts]# touch inotify_test.sh


2.编写检测增删改事件的脚本,内容如下
#!bin/bash
cmd="/usr/bin/inotifywait"
$cmd -mrq --timefmt '%y-%m-%d %T' --format '%T %w %f 检测事件为：%e' -e close_write,delete /data | \
while read line
do
        cd /data && \
        rsync -az --delete /data/  rsync_backup@192.168.37.202::backup
#rsync -az --delete $line rsync_backup@192.168.37.202::backup
done


脚本解释：
# 当删除事件动作发生，用rsync对整个目录复制
[! -e "$line"] && cd /data && \
# 对整个目录复制，然后终止当前循环
rsync -az --delete ./ rsync_backup@192.168.178.110::backup && continue

# 处理增删改事件的动作，针对修改的文件进行复制，提升同步性能
rsync -az --delete $line rsync_backup@192.168.178.110::backup
done

3.给脚本授权、增加可执行权限
[root@nfs myscripts]# chmod +x inotify_test.sh 
[root@nfs myscripts]# ll
总用量 4
-rwxr-xr-x 1 root root 241 10月 14 18:58 inotify_test.sh


4.区分增改、删除事件，针对性的复制

```



在nfs01机器上执行脚本

```shell
1.在nfs客户端前台执行脚本
[root@nfs myscripts]# sh -x inotify_test.sh 

2.在nfs客户端分别增加、删除、修改文件
[root@nfs data]# touch 11.txt
[root@nfs data]# echo "ni hao">11.txt
[root@nfs data]# touch 22.txt
[root@nfs data]# cat 11.txt 
ni hao



3.查看rsync服务器/backup目录下的内容是否与nfs机器的/data下数据一致
[root@rsync backup]# ls
11.txt  22.txt
[root@rsync backup]# cat 11.txt 
ni hao


```

![](notes/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201014202234.png)

放置后台执行脚本

```shell
测试脚本没问题后，可以将脚本运行在后台，实时监听文件变化，进行同步，保证数据备份安全
1.脚本放置后台运行，在前台运行会占用终端，且终端关了，任务会断
#一种写法,后台运行且将标准错误、正确信息重定向写入到空洞设备
[root@nfs myscripts]# sh inotify_test.sh 1>/dev/null 2>/dev/null &
#第二种写法
[root@nfs myscripts]# sh inotify_test.sh >/dev/null 2>&1
[1] 2524
[root@nfs myscripts]# jobs
[1]+  运行中               sh inotify_test.sh > /dev/null 2> /dev/null &


2.该任务添加至开机启动文件
[root@nfs myscripts]# tail -2 /etc/rc.local
/bin/bash /myscripts/inotify_test.sh >/dev/null 2>&1 &


```



Inotify优化参数

```shell
有关inotify的内核参数文件，可以针对企业需求进行优化，修改如下
[root@nfs01 scripts]# cat /proc/sys/fs/inotify/max_*
16384
128
8192

[root@nfs01 scripts]# echo "50000000" > /proc/sys/fs/inotify/max_user_watches
[root@nfs01 scripts]# echo "50000000" > /proc/sys/fs/inotify/max_queued_events
```



### 

### **6.15Sersync工具介绍**

**Sersync**

```
提到数据同步就必然会谈到rsync，一般简单的服务器数据传输会使用ftp/sftp等方式，但是这样的方式效率不高，不支持差异化增量同步也不支持实时传输。针对数据实时同步需求大多数人会选择rsync+inotify-tools的解决方案，sersync是国人基于前两者开发的工具，不仅保留了优点同时还强化了实时监控，文件过滤，简化配置等功能，帮助用户提高运行效率，节省时间和网络资源。
```

Sersync项目利用Inotify和Rsync工具技术实现对服务器数据实时复制。

当事件发生变化后，利用rsync命令把变化的数据复制到远端服务器上。

Sersync特点

- 使用C++编写，支持对监控事件的过滤
- Sersync采用xml配置文件，由守护进程启动，配置起来比起简易的`inotify+rsync更简单`
- 使用多线程复制，可以并发复制多个不同文件，效率更高
- Sersync自带异常检测机制，可以通过`失败队列`对出错的文件重新复制
- 自带crontab功能，实现对`失败队列`中的文件定时整体复制
- 自带socket和HTTP协议扩展，定制特殊需求，二次开发

**Sersync软件架构原理**

![](/../../notes/image-20200316144938926-1603868927511.png)

上图执行原理解释

1. Inotify监控指定目录对应事件的变化，当有事件变化时进入事件过滤队列
2. 过滤队列负责过滤掉不需要触发复制的数据，也可以过滤短时间内产生的重复Inotify事件信息，过滤后的事件触发Rsync对应变化数据进行复制。
3. 图中线程组（线程是等待线程队列的守护线程），当事件队列中中有事件发生后，线程组守护线程会逐个唤醒复制线程（线程就是干活的工人，没活的时候打盹，来活了逐个唤醒准备干活），当队列的Inotify事件较多的时候，复制线程就会全部唤醒一起工作，提升复制效率。（活太多，所有工人全部喊起来，加快工作效率）
4. 除了线程组以外，还有Sersync服务线程负责处理`复制失败的文件`，它们再次复制，对于再次复制失败的文件（执行失败的命令），会记录到rsync_fail_log.sh脚本中，然后再定期执行脚本，同时利用自带的cron功能，实现每隔一段时间将所有未复制的数据整体复制。

### **6.16Sersync配置文件部署**

**Sersync部署**

==**确保rsync服务正确，c/s端**==

```shell
1.大前提Rsync Daemon服务正确
[root@nfs01 scripts]# rsync -avz --delete /data/ rsync_backup@192.168.178.110::backup
```

==**确保当前客户端机器，是否支持Inotify**==

```shell
[root@nfs01 scripts]# ls /proc/sys/fs/inotify/
max_queued_events  max_user_instances  max_user_watches
```



**==Sersync安装==**

```shell
1.资料参考地址
https://github.com/wsgzao/sersync

2.百度云盘获取
[root@nfs opt]# yum install lrzsz -y	#安装工具后可直接从windows拖取文件到linux
[root@nfs opt]# ls
sersync_installdir_64bit

3.解压缩
[root@nfs opt]# unzip sersync_installdir_64bit.zip 

[root@nfs opt]# ls
sersync_installdir_64bit  sersync_installdir_64bit.zip


4.授权sersync、让它可以使用sersync命令
[root@nfs bin]# pwd
/opt/sersync_installdir_64bit/sersync/bin

[root@nfs bin]# chmod +x /opt/sersync_installdir_64bit/sersync//bin/sersync
[root@nfs bin]# ll
总用量 1768
-rwxr-xr-x 1 root root 1810128 10月 26 2011 sersync

```



==**Sersync配置文件**==

```shell
1.修改配置文件，修改如下部分
[root@nfs01 conf]# vim /MyInotify/tools/sersync_installdir_64bit/sersync/conf/confxml.xml

# 配置文件解释
# sersync的过滤功能，排除指定的文件不复制
  6     <filter start="false">
  7         <exclude expression="(.*)\.svn"></exclude>
  8         <exclude expression="(.*)\.gz"></exclude>
  9         <exclude expression="^info/*"></exclude>
 10         <exclude expression="^static/*"></exclude>
 11     </filter>

# 指定监控事件，也就是触发监控管理的事件，true开启，false关闭
 12     <inotify>
 13         <delete start="true"/>
 14         <createFolder start="true"/>
 15         <createFile start="true"/>
 16         <closeWrite start="true"/>
 17         <moveFrom start="true"/>
 18         <moveTo start="true"/>
 19         <attrib start="false"/>
 20         <modify start="false"/>
 21     </inotify>

 # sersync主要功能点
 23     <sersync>
 24         <localpath watch="/data">		#这里是nfs机器上要检测的目录
 # 填写rsync同步服务端ip地址，以及同步的模块名，支持复制到多台服务器
 25             <remote ip="192.168.37.202" name="bakcup"/>
 26             <!--<remote ip="192.168.8.39" name="tongbu"/>-->
 27             <!--<remote ip="192.168.8.40" name="tongbu"/>-->
 28         </localpath>

 # 配置rsync的信息
 29         <rsync>
 # 命令的参数
 30             <commonParams params="-artuz"/>
 # 填写rsync服务端验证的账号，密码文件
 31             <auth start="true" users="rsync_backup" passwordfile="/etc/rsync.password"/>
 32             <userDefinedPort start="false" port="874"/><!-- port=874 -->
 33             <timeout start="false" time="100"/><!-- timeout=100 -->
 34             <ssh start="false"/>
 35         </rsync>
```



### **6.17Sersync实践**

Sersync部署应用

```shell
1.生成sersync命令快捷键
[root@nfs bin]# ln -s /opt/sersync_installdir_64bit/sersync/bin/sersync /usr/local/bin/

2.查看命令帮助
[root@nfs01 conf]# sersync -h
set the system param
execute：echo 50000000 > /proc/sys/fs/inotify/max_user_watches
execute：echo 327679 > /proc/sys/fs/inotify/max_queued_events
parse the command param
_______________________________________________________ 
参数-d:启用守护进程模式
参数-r:在监控前，将监控目录与远程主机用rsync命令推送一遍
参数-n: 指定开启守护线程的数量，默认为10个
参数-o:指定配置文件，默认使用confxml.xml文件
参数-m:单独启用其他模块，使用 -m refreshCDN 开启刷新CDN模块
参数-m:单独启用其他模块，使用 -m socket 开启socket模块
参数-m:单独启用其他模块，使用 -m http 开启http模块
不加-m参数，则默认执行同步程序
________________________________________________________________
```

Sersync软件服务开启，命令如下

```shell
[root@nfs /]# sersync -r -d -o /opt/sersync_installdir_64bit/sersync/conf/confxml.xml
set the system param
execute：echo 50000000 > /proc/sys/fs/inotify/max_user_watches
execute：echo 327679 > /proc/sys/fs/inotify/max_queued_events
parse the command param
option: -r 	rsync all the local files to the remote servers before the sersync work
option: -d 	run as a daemon
option: -o 	config xml name：  /opt/sersync_installdir_64bit/sersync/conf/confxml.xml
daemon thread num: 10
parse xml config file
host ip : localhost	host port: 8008
daemon start，sersync run behind the console 
config xml parse success
please set /etc/rsyncd.conf max connections=0 Manually
sersync working thread 12  = 1(primary thread) + 1(fail retry thread) + 10(daemon sub threads) 
Max threads numbers is: 22 = 12(Thread pool nums) + 10(Sub threads)
please according your cpu ，use -n param to adjust the cpu rate
------------------------------------------
rsync the directory recursivly to the remote servers once
working please wait...
execute command: cd /data && rsync -artuz -R --delete ./ 192.168.37.202::mydata >/dev/null 2>&1 
run the sersync: 
watch path is: /data
```

添加sersync命令至开机启动

```shell
[root@nfs opt]# echo '/opt/sersync_installdir_64bit/sersync/bin/sersync -d' >> /etc/rc.local

[root@nfs opt]# tail -1 /etc/rc.local 
/opt/sersync_installdir_64bit/sersync/bin/sersync -d

```

命令部署测试

![image-20200316212543664](/../../notes/image-20200316212543664.png)



