## **七、互联网服务之自动化部署**

### **7.1自动化运维介绍**

【Ansible自动化运维】

**==人工运维时代==**

运维人员大多需要维护数量众多的机器，反复重复的劳动力，很多机器需要同时部署相同的服务或是执行命令，还得反复登录不同的机器执行。

例如在backup服务器上部署Rsync服务，需要在所有其他的服务器上部署Rsync客户端配置一遍。

一台台机器登录执行命令实在太繁琐，运维人员也常用Xshell、SecureCRT之类的工具添加多个服务器的标签，提高快速连接服务器的效率。

**==自动化运维时代==**

SSH自动化运维时代是指2003~2012年，当时SSH自动化运维是很流行的，通过再管理机器统一创建秘钥对，将私钥留在管理机上，公钥发到所有被管理的机器，然后开发脚本实现批量管理。

系统管理员日常会进行大量的重复性操作，例如安装软件，修改配置文件，创建用户，批量执行命令等等。如果主机数量庞大，单靠人工维护实在让人难以忍受。

早期运维人员会根据自己的生产环境来写特定脚本完成大量重复性工作，这些脚本复杂且难以维护。

系统管理员面临的问题主要是1、系统配置管理，2、远程执行命令，因此诞生了很多开源软件，系统维护方面有fabric、puppet、chef、ansible、saltstack等，这些软件擅长维护系统状态或方便的对大量主机进行批量的命令执行。

其中有两款软件都是用Python语言开发的，也就是`saltstack`、`ansible`，学习简单，功能强大。

**==自动化运维趋势==**

如今的自动化运维，不再是一个批量自动化管理软件就可以解决所有问题了，运维管理高速发展，从人肉运维到自动化运维，再到数据化运维、可视化运维、到AI智能运维，运维界倡导DevOps、AIOps运维，前景十分广阔，给用户更广阔的施展空间。

==**自动化运维好处**==

- 提高工作效率，减少重复性工作
- 大大减少人为出错的可能性
- 数据化管理、数据化汇报、问题可追溯

==**【Ansible介绍】**==

Ansible是一个同时管理多个远程主机的软件（任何可以通过SSH协议登录的机器），因此Ansible可以管理`远程虚拟机`、`物理机`，也可以是本地主机。

Ansible通过SSH协议实现`管理节点`、`远程节点`的通信。只要是能够SSH登录的主机完成的操作，都可以通Ansible自动化操作，比如批量复制、批量删除、批量修改、批量查看、批量安装、重启、更新等。

==【Ansible特点】==

Ansible的编排引擎可以出色的完成配置管理、流程控制、资源部署等多方面的操作。和其他IT自动化产品比较，Ansible无须安装客户端软件，管理简便，功能强大，便于维护。

Ansible基于Python开发，由主要的Paramiko和PyYAML两个关键模块构建。

- 安装部署简单，学习曲线平坦
- 管理主机便捷，支持多台主机并行管理
- 无须单独在被管理主机上安装客户端软件（no agents），无须占用其他端口，仅利用SSH服务工作。
- 远程执行安全，轻松对执行的内容进行审计、评估、重写
- 能够立即管理远程主机，无须事先安装任何客户端。
- 不仅支持python、还可以使用其他语言开发模块。
- 非root账户可用
- 不需要安装服务端(no servers)，不需要守护进程服务
- 有活跃的官方社区

在云计算时代，基础架构必须满足按需自动伸缩、按使用量计费的基本特性，因此自动化运维软件是必备的工具之一。

### **7.2Ansible软件架构介绍**

**==Ansible软件架构==**

Ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是Ansible所运行的模块，Ansible只是提供一种框架。

<img src="notes/image-20200317093301268-1603867403679.png" style="zoom:50%;" />

==Ansible服务器规划==

| 主机名          | ip             | 用途            | 说明       |
| --------------- | -------------- | --------------- | ---------- |
| Ansible_machine | 192.168.37.203 | 中心分发服务器  | 管理机     |
| rsync_server    | 192.168.37.202 | Rsync备份服务器 | 未配免密钥 |
| web_server      | 192.168.37.200 | web01服务器     | 未配免密钥 |
| nfs_server      | 192.168.37.201 | nfs共享存储     | 未配密钥   |



### **7.3Ansible机器环境准备**

**==Ansible管理机安装部署==**

```shell
1.在管理节点，管理机上安装ansible软件
yum install epel-release -y
yum install ansible libselinux-python -y

2.检查ansible软件
rpm -ql ansible |grep -E '^/etc|^/usr/bin'

/etc/ansible						 #Ansible软件主目录
/etc/ansible/ansible.cfg				 #Ansible主配置文件
/etc/ansible/hosts						#Ansible软件被管理节点的主机列表文件
/etc/ansible/roles
/usr/bin/ansible						 #Anisble批量管理命令
/usr/bin/ansible-2
/usr/bin/ansible-2.7
/usr/bin/ansible-config
/usr/bin/ansible-connection
/usr/bin/ansible-console
/usr/bin/ansible-console-2
/usr/bin/ansible-console-2.7
/usr/bin/ansible-doc
/usr/bin/ansible-doc-2
/usr/bin/ansible-doc-2.7
/usr/bin/ansible-galaxy
/usr/bin/ansible-galaxy-2
/usr/bin/ansible-galaxy-2.7
/usr/bin/ansible-inventory
/usr/bin/ansible-playbook					 #Ansible程序剧本执行命令
/usr/bin/ansible-playbook-2
/usr/bin/ansible-playbook-2.7
/usr/bin/ansible-pull
/usr/bin/ansible-pull-2
/usr/bin/ansible-pull-2.7
/usr/bin/ansible-test
/usr/bin/ansible-vault
/usr/bin/ansible-vault-2
/usr/bin/ansible-vault-2.7

3.检查Ansible版本
[root@Ansible opt]# ansible --version
ansible 2.9.13
  config file = /etc/ansible/ansible.cfg
  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python2.7/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 2.7.5 (default, Apr 11 2018, 07:36:10) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)]

```

==**Anisble命令及参数**==



```shell
ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。

Options:
  -a MODULE_ARGS, --args=MODULE_ARGS    
             #module arguments
             #指定执行模块使用的参数  
  --ask-vault-pass      
             #ask for vault password
             #加密playbook文件时提示输入密码
  -B SECONDS, --background=SECONDS
             #run asynchronously, failing after X seconds(default=N/A)
             #后台运行超时时间,异步运行，X秒之后失败
  -C, --check           
             #don't make any changes; instead, try to predict some of the changes that may occur
             #模拟执行，不会真正在机器上执行(查看执行会产生什么变化)
  -D, --diff            
             #when changing (small) files and templates, show the differences in those files; works great with --check
             #当更新的文件数及内容较少时，该选项可显示这些文件不同的地方，该选项结合-C用会有较好的效果
  -e EXTRA_VARS, --extra-vars=EXTRA_VARS
             #set additional variables as key=value or YAML/JSON
             #执行命令时添加额外参数变量
  -f FORKS, --forks=FORKS
             #specify number of parallel processes to use(default=5)
             #并行任务数。FORKS被指定为一个整数,默认是5
  -h, --help            
             #show this help message and exit
             #打开帮助文档API
  -i INVENTORY, --inventory-file=INVENTORY
             #specify inventory host path(default=/etc/ansible/hosts) or comma separated host list.
             #指定要读取的Inventory文件
  -l SUBSET, --limit=SUBSET
             #further limit selected hosts to an additional pattern
             #限定执行的主机范围
  --list-hosts          
             #outputs a list of matching hosts; does not execute anything else
             #列出执行匹配到的主机，但并不会执行
  -m MODULE_NAME, --module-name=MODULE_NAME
             #module name to execute (default=command)
             #指定执行使用的模块，默认使用 command 模块
  -M MODULE_PATH, --module-path=MODULE_PATH
             #specify path(s) to module library (default=None)
             #要执行的模块的路径
  --new-vault-password-file=NEW_VAULT_PASSWORD_FILE
             #new vault password file for rekey
             #    
  -o, --one-line        
             #condense output
             #压缩输出，摘要输出.尝试一切都在一行上输出
  --output=OUTPUT_FILE  
             #output file name for encrypt or decrypt; use - for stdout
             #
  -P POLL_INTERVAL, --poll=POLL_INTERVAL
             #set the poll interval if using -B (default=15)
             #设置轮询间隔，每隔数秒。需要- B
  --syntax-check        
             #perform a syntax check on the playbook, but do not execute it
             #检查Playbook中的语法书写
  -t TREE, --tree=TREE  
             #log output to this directory
             #将日志内容保存在该输出目录,结果保存在一个文件中在每台主机上
  --vault-password-file=VAULT_PASSWORD_FILE
             #vault password file
             #
  -v, --verbose         
             #verbose mode (-vvv for more, -vvvv to enable connection debugging)
             #执行详细输出
  --version             
             #show program's version number and exit
             #显示版本


  Connection Options:
    control as whom and how to connect to hosts


    -k, --ask-pass      
             #ask for connection password
             #
    --private-key=PRIVATE_KEY_FILE, --key-file=PRIVATE_KEY_FILE
             #use this file to authenticate the connection
             #
    -u REMOTE_USER, --user=REMOTE_USER
             #connect as this user (default=None)
             #指定远程主机以USERNAME运行命令
    -c CONNECTION, --connection=CONNECTION
             #connection type to use (default=smart)
             #指定连接方式，可用选项paramiko (SSH)、ssh、local，local方式常用于crontab和kickstarts
    -T TIMEOUT, --timeout=TIMEOUT
             #override the connection timeout in seconds(default=10)
             #SSH连接超时时间设定，默认10s
    --ssh-common-args=SSH_COMMON_ARGS
             #specify common arguments to pass to sftp/scp/ssh (e.g.ProxyCommand)
             #
    --sftp-extra-args=SFTP_EXTRA_ARGS
             #specify extra arguments to pass to sftp only (e.g. -f, -l)
             #
    --scp-extra-args=SCP_EXTRA_ARGS
             #specify extra arguments to pass to scp only (e.g. -l)
             #
    --ssh-extra-args=SSH_EXTRA_ARGS
             #specify extra arguments to pass to ssh only (e.g. -R)
             #


  Privilege Escalation Options:
    control how and which user you become as on target hosts


    -s, --sudo          
             #run operations with sudo (nopasswd) (deprecated, use become)
             #相当于Linux系统下的sudo命令
    -U SUDO_USER, --sudo-user=SUDO_USER
             #desired sudo user (default=root) (deprecated, use become)
             #使用sudo，相当于Linux下的sudo命令
    -S, --su            
             #run operations with su (deprecated, use become)
             #
    -R SU_USER, --su-user=SU_USER
             #run operations with su as this user (default=root) (deprecated, use become)
             #
   -b, --become        
             #run operations with become (does not imply password prompting)
             #
    --become-method=BECOME_METHOD
             #privilege escalation method to use (default=sudo),valid choices: [ sudo | su | pbrun | pfexec | doas |dzdo | ksu | runas ]
             #
    --become-user=BECOME_USER
             #run operations as this user (default=root)
             #
    --ask-sudo-pass     
             #ask for sudo password (deprecated, use become)
             #
    --ask-su-pass       
             #ask for su password (deprecated, use become)
             #
    -K, --ask-become-pass
             #ask for privilege escalation password
             #
```





**==Ansible被管理节点==**

需要安装的机器

- web_server
- nfs_server
- rsync_server

```shell
安装如下依赖软件
yum install epel-release libselinux-python -y
```

**==Ansible批量管理方式==**

Ansible批量管理主机有两种方式：

- 传统的密码认证
- 密钥管理

【配置基础环境，Ansible管理的主机清单】

```shell
1.备份旧配置文件
cp  /etc/ansible/hosts{,.bak}

2.添加被管理机器的ip地址
[root@Ansible ansible]# tail -f hosts
[syh]
192.168.37.200
192.168.37.201
192.168.37.202

```



### **7.4Ansible管理方式之密码验证**

**==SSH密码认证批量管理主机==**

Ansible是直接利用`本地SSH`以及一些`远程SSH服务`作为客户端的，且基本上客户端的SSH服务默认都是开启的，无须额外配置

```shell
1.在m01机器，执行ansible命令批量远程管理
ansible syh -m command -a "hostname" -k -u root

SSH password: 
192.168.37.201 | FAILED | rc=-1 >>
Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host's fingerprint to your known_hosts file to manage this host.
192.168.37.200 | FAILED | rc=-1 >>
Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host's fingerprint to your known_hosts file to manage this host.
192.168.37.202 | FAILED | rc=-1 >>
Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host's fingerprint to your known_hosts file to manage this host.


#出现以上报错、只需要使用ssh远程分别连接这三台机器、~/.ssh/known_hosts 会生成三个指纹信息


[root@Ansible .ssh]# cat ~/.ssh/known_hosts 
192.168.37.200 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDFyqkiXPBZVQ7Rb3E82yHHh4HHCkwEWPS9ttN7qlrWRSUN5jMpk9dWYHaLurcdf8BFgJEH/UNR3SFy/OpcDHWs=
192.168.37.201 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDnPUqUc2UGc0IofGAHIgkKhMrmY83aF3rLO8XOhK1e06xET4efdnPWvMCmai+dRKDBF9r4MQae0iiYfM/cqT2s=
192.168.37.202 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNyL0FtJNbPuab6GA1+JewQp76LRwJBNlcEJZ+VVfKL6eKLYt9Uf35QhJBU82CROiuVO7gEwHJXVPlkkF3VlK38=




```

【错误解释】

![](notes/image-20200317105030840-1603867394516.png)

【解决办法】

```shell
#出现以上报错、只需要使用ssh远程分别连接这三台机器、~/.ssh/known_hosts 会生成三个指纹信息,再次执行上述命令即可
ssh root@192.168.37.200
ssh root@192.168.37.201
ssh root@192.168.37.202

[root@Ansible .ssh]# cat ~/.ssh/known_hosts 
192.168.37.200 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDFyqkiXPBZVQ7Rb3E82yHHh4HHCkwEWPS9ttN7qlrWRSUN5jMpk9dWYHaLurcdf8BFgJEH/UNR3SFy/OpcDHWs=
192.168.37.201 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDnPUqUc2UGc0IofGAHIgkKhMrmY83aF3rLO8XOhK1e06xET4efdnPWvMCmai+dRKDBF9r4MQae0iiYfM/cqT2s=
192.168.37.202 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNyL0FtJNbPuab6GA1+JewQp76LRwJBNlcEJZ+VVfKL6eKLYt9Uf35QhJBU82CROiuVO7gEwHJXVPlkkF3VlK38=
```

【再次执行命令测试anisble】

```shell

#
[root@Ansible /]# ansible syh -m command -a "hostname" -k -u root
SSH password: 
192.168.37.202 | CHANGED | rc=0 >>
rsync.localdomain
192.168.37.201 | CHANGED | rc=0 >>
nfs.localdomain
192.168.37.200 | CHANGED | rc=0 >>
webserver.localdomain
syh：读取配置文件下的syh组、只针对syh模块下的主机生效
-a：指定执行模块使用的参数  
-m：默认指定command模块
-k：询问连接密码
-u：指定以什么用户连接

指定syh组 指定command模块、root用户 、要求输入连接密码的去找到这两台主机的主机名
```

**==【配置免密登录客户端机器，批量管理】==**

每次执行ansible命令都要输入root的用户密码，如果主机密码不一致，还得输入多次

可以在`/etc/ansible/hosts`主机列表文件中添加指定配置参数，实现远程管理主机的效果

**对于主机列表文件的配置参数修改**

| 参数             | 参数类型 | 参数说明                  |
| ---------------- | -------- | ------------------------- |
| Ansible_ssh_host | 通用连接 | 远程主机ip                |
| ansible_ssh_port | ↑        | 设置SSH连接端口，默认22   |
| Ansible_ssh_user | ↑        | 默认SSH远程连接的用户身份 |
| Ansible_ssh_pass | 连接控制 | 指定SSH远程主机密码       |

Ansible软件使用的前提是SSH+KEY免密验证的环境，如果没有配置也可以使用Ansible，如下

```shell
1.修改/etc/ansible/hosts文件，在文件中定义主机密码
[root@Ansible ~]# tail -4 /etc/ansible/hosts
192.168.37.200 ansible_ssh_user=root ansible_ssh_pass=root
192.168.37.201 ansible_ssh_user=root ansible_ssh_pass=root
192.168.37.202 ansible_ssh_user=root ansible_ssh_pass=root
```

此时可以不用输入密码，即可远程操作服务器

```shell
# 参数-k  -m  都是可以省略的  -m是默认参数，-k 输入密码也不用了
[root@Ansible ~]# ansible syh  -a 'hostname'
192.168.37.201 | CHANGED | rc=0 >>
nfs.localdomain
192.168.37.202 | CHANGED | rc=0 >>
rsync.localdomain
192.168.37.200 | CHANGED | rc=0 >>
webserver.localdomain

```





### **7.5Ansible管理方式之免密验证****

**==SSH密钥方式批量管理主机==**

此方法比起SSH密码登录更为安全方便

```shell
1.在m01管理机创建SSH密钥对
[root@Ansible .ssh]# ssh-keygen -f ~/.ssh/id_rsa -P "" > /dev/null 2>&1

2.检查公私钥文件
[root@Ansible .ssh]# ll ~/.ssh/
总用量 12
-rw-------. 1 root root 1679 10月 15 19:12 id_rsa		#私钥文件
-rw-r--r--. 1 root root  406 10月 15 19:12 id_rsa.pub	#公钥文件
-rw-r--r--. 1 root root  528 10月 15 13:55 known_hosts

```

交互式分发公钥信息，把ssh服务创建的公钥信息分发到客户端机器

直接编写批量分发脚本，省时省力

```shell
1.编写脚本如下
[root@Ansible myscripts]# vim /myscripts/send.sh
#!/bin/bash
rm -rf ~/.ssh/id_rsa*
ssh-keygen -f ~/.ssh/id_rsa -P "" > /dev/null 2>&1
SSH_Pass=root
Key_Path=~/.ssh/id_rsa.pub
for ip in 200 201 202
do
    sshpass -p$SSH_Pass ssh-copy-id -i $Key_Path "-o StrictHostKeyChecking=no" 192.168.37.$ip
done

2.给与执行的权限
[root@Ansible myscripts]# chmod +x send.sh 

3.执行脚本，快速分发公钥，实现免密登录
[root@Ansible myscripts]# sh send.sh 

```

修改Ansible被管理主机列表文件，可以注释掉主机密码

```shell

[root@Ansible myscripts]# tail -10  /etc/ansible/hosts

[syh]
#192.168.37.200 ansible_ssh_user=root ansible_ssh_pass=root
#192.168.37.201 ansible_ssh_user=root ansible_ssh_pass=root
#192.168.37.202 ansible_ssh_user=root ansible_ssh_pass=root

192.168.37.200
192.168.37.201
192.168.37.202

```

再次Ansible命令远程批量执行命令，已经不再需要输入密码，非常简单

```shell
[root@Ansible myscripts]# ansible syh -a "hostname"
192.168.37.202 | CHANGED | rc=0 >>
rsync.localdomain
192.168.37.201 | CHANGED | rc=0 >>
nfs.localdomain
192.168.37.200 | CHANGED | rc=0 >>
webserver.localdomain
```

### 总结

在生产环境下，ansible管理连接方式二选一即可

要求下更高的话，采用普通用户管理再提权管理。

主机连接安全性上，若是用了密钥管理，那么对于管理机的安全性就得严格把控，最好禁止SSH外网连接，启用内网VPN连接，加强安全性，否则管理机被入侵，对于客户端机器是很危险的。

### **7.6Ansible模块之ad-hoc**

**==Ansible批量管理模式与命令==**

Ansible实现批量管理主机的模式主要有俩：

- 利用ansible命令实现批量管理（ad-hoc）模式
- 利用ansible剧本实现批量管理（playbook）模式

Ad-hoc和playbook的关系就好比shell命令与shell scripts的关系

==**ad-hoc模式**==

Ansible的ad-hoc模式也就是ansible的命令行模式，该模式通常用来临时处理一些任务。例如

- 临时批量查看所有被管控机器的内存、负载、磁盘
- 临时批量分发某个特定文件

==**Playbook模式**==

Ansible的playbook模式就是针对特定的具体较大的任务，事先写好执行剧本，然后在其他机器上批量执行相同的任务，属于定制化的批量执行任务，例如

- 一键安装Rsync
- 一键搭建LNMP集群等

**Ansible命令**

![](notes/image-20200317135336959-1603867388261.png)

ansible批量管理命令主要涉及6部分

1. ansible主命令
2. 指定ansible管理的主机信息，可以是主机组名、主机ip地址、或是`all` （也可以写*，表示所有主机）
3. 调用ansible的模块参数 `-m`
4. 指定用哪一个功能模块
5. 调用对应模块的功能参数
6. 执行对应模块中的哪些功能

==**ansible-doc命令**==

列出所有的ansible支持的模块

```shell
# 模块支持的有3000+数量
[root@m01 ~]# ansible-doc -l 
# 查看某个模块的具体用法
[root@m01 ~]# ansible-doc -s command
```

### **7.7Ansible模块之Command模块**

**==Ansible模块详解==**

Ansible自动化软件的核心功能就在于其众多的模块，可以说学习Ansible就是学习模块的使用，剩余的是对Ansible剧本编写的熟练度。

**==command模块==**

该模块作用：在远程节点上执行一个命令

| 选项参数          | 选项说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| chdir             | 在执行命令前，先通过cd命令进入指定目录                       |
| creates           | 定义一个文件是否存在，若不存在，则运行相应命令；存在则跳过   |
| free_form（必须） | 参数信息中可以输入任何系统命令，实现远程管理                 |
| removes           | 定义一个文件是否存在，如果存在，则运行相应命令；如果不存在则跳过 |

command模块是ansible命令基本模块，可以不用指定，其次要注意的是

- 使用command模块执行远程命令，命令不得用变量（$HOME）、不得出现特殊符号`< 、>、|、；、&`，否则无法识别，需要则使用shell模块实现

**==【command案例】==**

**【获取所有被管控机器负载信息】**

```shell
# 最简写法，uptime可以换成其他任意linux命令，注意不得携带管道符、重定向等符号
[root@Ansible myscripts]# ansible  syh -m command -a 'uptime'
192.168.37.201 | CHANGED | rc=0 >>
 19:42:26 up 52 min,  2 users,  load average: 0.00, 0.01, 0.05
192.168.37.200 | CHANGED | rc=0 >>
 19:42:26 up 52 min,  2 users,  load average: 0.00, 0.01, 0.05
192.168.37.202 | CHANGED | rc=0 >>
 19:42:26 up 48 min,  2 users,  load average: 0.00, 0.01, 0.05

```

**【切换到/tmp目录，然后输出当前目录】**

```shell
[root@Ansible myscripts]# ansible syh -m command -a 'pwd chdir=/tmp'
192.168.37.201 | CHANGED | rc=0 >>
/tmp
192.168.37.202 | CHANGED | rc=0 >>
/tmp
192.168.37.200 | CHANGED | rc=0 >>
/tmp
```

**【command模块的参数creates实践】**

```shell

#creates--判断存在该目录则跳过、不存在则执行
#/tmp目录存在、所以跳过
[root@Ansible myscripts]# ansible syh -m command -a 'pwd creates=/tmp'
192.168.37.201 | SUCCESS | rc=0 >>
skipped, since /tmp exists
192.168.37.202 | SUCCESS | rc=0 >>
skipped, since /tmp exists
192.168.37.200 | SUCCESS | rc=0 >>
skipped, since /tmp exists

#/chaoren目录不存在、所以执行pwd
[root@Ansible myscripts]# ansible syh -m command -a 'pwd creates=/chaoren'
192.168.37.202 | CHANGED | rc=0 >>
/root
192.168.37.200 | CHANGED | rc=0 >>
/root
192.168.37.201 | CHANGED | rc=0 >>
/root

```



**==【removes实践】==**

```shell
#remove与creates相反、其作用是判断该目录存在则执行命令、不存在则跳过
#/chaoren目录在三台机器都不存在所以跳过
[root@Ansible myscripts]# ansible syh -m command -a 'ls /opt removes=/chaoren'
192.168.37.202 | SUCCESS | rc=0 >>
skipped, since /chaoren does not exist
192.168.37.201 | SUCCESS | rc=0 >>
skipped, since /chaoren does not exist
192.168.37.200 | SUCCESS | rc=0 >>
skipped, since /chaoren does not exist

#/tmp目录在三台机器都存在所以执行pwd
[root@Ansible myscripts]# ansible syh -m command -a 'ls /opt removes=/tmp'
192.168.37.202 | CHANGED | rc=0 >>

192.168.37.200 | CHANGED | rc=0 >>

192.168.37.201 | CHANGED | rc=0 >>
sersync_installdir_64bit
sersync_installdir_64bit.zip



```

**【command模块的参数warn】**

warn作用：可开启或关闭警告提示、开启为True、关闭为False

```shell
[root@Ansible myscripts]# ansible syh -m command -a 'chmod 000 /etc/hosts warn=True'
[WARNING]: Consider using the file module with mode rather than running 'chmod'.  If you need to use command because file is insufficient you can add
'warn: false' to this command task or set 'command_warnings=False' in ansible.cfg to get rid of this message.
192.168.37.200 | CHANGED | rc=0 >>

192.168.37.202 | CHANGED | rc=0 >>

192.168.37.201 | CHANGED | rc=0 >>

[root@Ansible myscripts]# ansible syh -m command -a 'chmod 000 /etc/hosts warn=False'
192.168.37.202 | CHANGED | rc=0 >>

192.168.37.201 | CHANGED | rc=0 >>

192.168.37.200 | CHANGED | rc=0 >>

```



### **7.8Ansible模块之shell模块****



**==shell模块==**

shell模块功能：在远程节点上执行命令（复杂的命令）

shell模块常用参数

| 选项参数          | 选项说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| chdir             | 在执行命令执行，通过cd命令进入指定目录                       |
| creates           | 定义一个文件是否存在，若不存在，则运行相应命令；存在则跳过   |
| free_form（必须） | 参数信息中可以输入任何系统命令，实现远程管理                 |
| removes           | 定义一个文件是否存在，如果存在，则运行相应命令；如果不存在则跳过 |

**==shell模块案例==**

**【批量查询sshd进程】**

```shell
[root@Ansible myscripts]# ansible syh -m shell -a 'ps -ef|grep sshd |grep -v grep'
192.168.37.201 | CHANGED | rc=0 >>
root       1302      1  0 18:50 ?        00:00:00 /usr/sbin/sshd -D
root       1561   1302  0 18:53 ?        00:00:00 sshd: root@pts/0
root       2774   1302  0 20:16 ?        00:00:00 sshd: root@pts/1
192.168.37.200 | CHANGED | rc=0 >>
root       1443      1  0 18:49 ?        00:00:00 /usr/sbin/sshd -D
root       1710   1443  0 18:53 ?        00:00:00 sshd: root@pts/0
root       2683   1443  0 20:16 ?        00:00:00 sshd: root@pts/1
192.168.37.202 | CHANGED | rc=0 >>
root       1305      1  0 18:53 ?        00:00:00 /usr/sbin/sshd -D
root       1566   1305  0 18:55 ?        00:00:00 sshd: root@pts/0
root       2774   1305  0 20:16 ?        00:00:00 sshd: root@pts/1
```

**【批量执行远程脚本】**

**==注意的是，该脚本，必须在客户端机器上存在==**

通过一条命令，做如下事情

- 创建文件夹
- 生成sh脚本文件
- 赋予脚本可执行权限
- 执行脚本
- 忽略warning信息

```shell
[root@Ansible ~]# ansible syh -m shell -a "mkdir -p /server/scripts/;echo 'hostname' > /server/scripts/hostname.sh;chmod +x /server/scripts/hostname.sh;/usr/bin/bash /server/scripts/hostname.sh warn=False"
192.168.37.201 | CHANGED | rc=0 >>
nfs.localdomain
192.168.37.202 | CHANGED | rc=0 >>
rsync.localdomain
192.168.37.200 | CHANGED | rc=0 >>
webserver.localdomain
```



### **7.9Ansible模块之Script执行脚本**



**==script模块==**

模块功能：把本地脚本传输到远程节点上并运行脚本

比起`shell`模块，script模块功能更强大，管理中心本地有一份脚本，就可以在所有机器上运行。

**==scripts模块的功能参数==**

| 选项参数          | 选项说明                                                     |
| ----------------- | ------------------------------------------------------------ |
|                   |                                                              |
| creates           | 定义一个文件是否存在，若不存在，则运行相应命令；存在则跳过   |
| free_form（必须） | 参数信息中可以输入任何系统命令，实现远程管理                 |
| removes           | 定义一个文件是否存在，如果存在，则运行相应命令；如果不存在则跳过 |

**批量执行远程脚本**

1.在管理节点m01创建脚本

```shell
# echo -e 参数，开启转义符功能
[root@Ansible /]# mkdir -p /server/scripts
[root@Ansible /]# echo -e "pwd\nhostname" > /server/scripts/pwd.sh
[root@Ansible /]# cat /server/scripts/pwd.sh 
pwd
hostname
```

2.批量在所有客户端机器运行脚本

```shell
[root@Ansible /]# ansible syh -m script -a '/server/scripts/pwd.sh'
```

利用script模块批量让所有被管控机器执行脚本，该脚本不用在远程主机上存在



### **7.10Ansible模块之copy模块**

**==Ansible文件类型模块==**

==**copy模块**==

该模块功能，复制文件到远程主机

copy模块重要功能参数

![](notes/image-20200317155559101-1603867380671.png)

copy模块是远程推送数据模块，只能把数据推送给远程主机节点，无法拉取数据到本地

**==【批量远程复制文件】==**

```shell
1.先批量在客户端机器，创建一个普通用户、用户组
[root@Ansible /]# ansible syh -m shell -a 'useradd syh'
192.168.37.202 | CHANGED | rc=0 >>

192.168.37.201 | CHANGED | rc=0 >>

192.168.37.200 | CHANGED | rc=0 >>

[root@Ansible /]# ansible syh -m shell -a 'id syh'
192.168.37.201 | CHANGED | rc=0 >>
uid=1000(syh) gid=1000(syh) 组=1000(syh)
192.168.37.200 | CHANGED | rc=0 >>
uid=1000(syh) gid=1000(syh) 组=1000(syh)
192.168.37.202 | CHANGED | rc=0 >>
uid=1001(syh) gid=1001(syh) 组=1001(syh)

2.批量拷贝目录下的内容，发送至客户端节点

[root@Ansible /]# ansible syh -m copy -a 'src=/test/ dest=/tmp/ owner=syh group=syh mode=0755'

192.168.37.202 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": true, 
    "checksum": "da39a3ee5e6b4b0d3255bfef95601890afd80709", 
    "dest": "/tmp/haha.txt", 
    "gid": 1001, 
    "group": "syh", 
    "md5sum": "d41d8cd98f00b204e9800998ecf8427e", 
    "mode": "0755", 
    "owner": "syh", 
    "size": 0, 
    "src": "/root/.ansible/tmp/ansible-tmp-1602767429.91-3434-251333959316646/source", 
    "state": "file", 
    "uid": 1001
}
192.168.37.201 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": true, 
    "checksum": "da39a3ee5e6b4b0d3255bfef95601890afd80709", 
    "dest": "/tmp/haha.txt", 
    "gid": 1000, 
    "group": "syh", 
    "md5sum": "d41d8cd98f00b204e9800998ecf8427e", 
    "mode": "0755", 
    "owner": "syh", 
    "size": 0, 
    "src": "/root/.ansible/tmp/ansible-tmp-1602767429.92-3433-102278376564285/source", 
    "state": "file", 
    "uid": 1000
}
192.168.37.200 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": true, 
    "checksum": "da39a3ee5e6b4b0d3255bfef95601890afd80709", 
    "dest": "/tmp/haha.txt", 
    "gid": 1000, 
    "group": "syh", 
    "md5sum": "d41d8cd98f00b204e9800998ecf8427e", 
    "mode": "0755", 
    "owner": "syh", 
    "secontext": "unconfined_u:object_r:admin_home_t:s0", 
    "size": 0, 
    "src": "/root/.ansible/tmp/ansible-tmp-1602767430.08-3432-217551659756469/source", 
    "state": "file", 
    "uid": 1000
}


3.远程批量查看远程节点机器的文件信息
192.168.37.201 | CHANGED | rc=0 >>
ansible_command_payload_ZMiW2N
haha.txt							#这个文件
ks-script-euaGGh
rsync_fail_log.sh
systemd-private-f504e6f2e6dd4b29938e45360afb63d3-chronyd.service-8KJDpq
vmware-root
yum.log
192.168.37.202 | CHANGED | rc=0 >>
ansible_command_payload_zCKopT
haha.txt
hosts
ks-script-SLl2JV
systemd-private-aa592a034ad4414bb7e48f099068f7c2-chronyd.service-lIqtn2
vmware-root
yum.log
192.168.37.200 | CHANGED | rc=0 >>
ansible_command_payload_Gcf1D7
haha.txt
hosts
ks-script-GMhIaa
systemd-private-9a48cf8de07d44a7886643d7e8450acc-chronyd.service-LPBTmt
vmware-root
yum.log

```

**远程批量复制文件、备份、追加内容**

```shell

1.远程追加内容并备份文件
[root@Ansible /]# ansible syh -m copy -a "content='hello how are you' dest=/tmp/haha.txt backup=yes"

2.远程查看追加的内容和备份文件
[root@Ansible /]# ansible syh -m shell -a "ls /tmp/"
[root@Ansible /]# ansible syh -m shell -a "cat /tmp/haha.txt"
192.168.37.202 | CHANGED | rc=0 >>
hello how are you
192.168.37.201 | CHANGED | rc=0 >>
hello how are you
192.168.37.200 | CHANGED | rc=0 >>
hello how are you


```

上述命令含义是

```shell
批量对服务器文件拷贝操作，把content参数定义的内容，写入到/tmp/haha.txt文件中，并且对tmp/haha.txt旧文件内容备份
```

远程检查命令执行结果

注意，得使用shell模块，支持通配符，更方便

```shell
[root@Ansible /]# ansible syh -m shell -a "ls /tmp/haha*"
192.168.37.202 | CHANGED | rc=0 >>
/tmp/haha.txt
/tmp/haha.txt.3808.2020-10-15@21:17:20~
192.168.37.200 | CHANGED | rc=0 >>
/tmp/haha.txt
/tmp/haha.txt.3447.2020-10-15@21:17:20~
192.168.37.201 | CHANGED | rc=0 >>
/tmp/haha.txt
/tmp/haha.txt.3803.2020-10-15@21:17:20~
```





### **7.11Ansible模块之file文件管理**

**==file模块==**

file模块作用是`创建`、以及`设置`文件目录属性。

```shell
file模块参数：

force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no
group：定义文件/目录的属组
mode：定义文件/目录的权限
owner：定义文件/目录的属主
path：必选项，定义文件/目录的路径
recurse：递归的设置文件的属性，只对目录有效
src：要被链接的源文件的路径，只应用于state=link的情况
dest：被链接到的路径，只应用于state=link的情况
state：
  directory：如果目录不存在，创建目录
  file：如果文件不存在，不会被创建
  link：创建软链接
  hard：创建硬链接
  touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间
  absent：删除目录、文件或者取消链接文件
```

file模块主要用于创建文件、目录数据，以及对现有的文件、目录权限进行修改

==**file模块创建数据文件**==

**【远程创建文件夹】**

```shell
1.远程对多台机器创建/cc目录、
[root@Ansible /]# ansible syh -m file -a 'dest=/cc state=directory'
state=directory：若此/cc目录不存在则自动创建

2.远程查看多台机器的cc目录是否被创建
[root@Ansible /]# ansible syh -m shell -a 'ls -ld /c*'
192.168.37.201 | CHANGED | rc=0 >>
drwxr-xr-x 2 root root 6 10月 15 21:44 /cc
192.168.37.202 | CHANGED | rc=0 >>
drwxr-xr-x 2 root root 6 10月 15 21:44 /cc
192.168.37.200 | CHANGED | rc=0 >>
drwxr-xr-x. 2 root root 6 10月 15 21:44 /cc
```

**【远程批量生成文件】**

```shell
1.远程对多台机器以gid、uid都为syh用户创建/tmp/test.txt、并赋予755权限
[root@Ansible /]# ansible syh -m file -a 'path=/tmp/test.txt state=touch owner=syh group=syh mode=755'

2.查看多台机器的tmp下的txt文件
[root@Ansible /]# ansible syh -m shell -a 'ls -ld /tmp/*.txt'
192.168.37.202 | CHANGED | rc=0 >>
-rwxr-xr-x 1 syh syh 17 10月 15 21:17 /tmp/haha.txt
-rwxr-xr-x 1 syh syh  0 10月 15 21:50 /tmp/test.txt
192.168.37.201 | CHANGED | rc=0 >>
-rwxr-xr-x 1 syh syh 17 10月 15 21:17 /tmp/haha.txt
-rwxr-xr-x 1 syh syh  0 10月 15 21:50 /tmp/test.txt
192.168.37.200 | CHANGED | rc=0 >>
-rwxr-xr-x. 1 syh syh 17 10月 15 21:17 /tmp/haha.txt
-rwxr-xr-x. 1 syh syh  0 10月 15 21:50 /tmp/test.txt

```

**【远程创建软连接文件】**

```shell
1.创建文件的软连接
[root@Ansible ~]# ansible syh -m file -a "src=/etc/hosts  dest=/test_ansible/test2.txt state=link"

2.查看软连接是否生成
[root@Ansible ~]# ansible syh -m shell -a 'ls -l /test_ansible'
192.168.37.202 | CHANGED | rc=0 >>
总用量 0
-rw-r--r-- 1 root root  0 10月 15 22:06 test1.txt
lrwxrwxrwx 1 root root 10 10月 15 22:57 test2.txt -> /etc/hosts
192.168.37.201 | CHANGED | rc=0 >>
总用量 0
-rw-r--r-- 1 root root  0 10月 15 22:06 test1.txt
lrwxrwxrwx 1 root root 10 10月 15 22:57 test2.txt -> /etc/hosts
192.168.37.200 | CHANGED | rc=0 >>
总用量 0
-rw-r--r--. 1 root root  0 10月 15 22:06 test1.txt
lrwxrwxrwx. 1 root root 10 10月 15 22:57 test2.txt -> /etc/hosts

```



### **7.12Ansible模块之yum模块**



**==Ansible软件管理模块==**

**==yum模块==**

yum包管理模块，功能参数如下

<img src="notes/image-20200317164841904-1603867373425.png" style="zoom:50%;" />



<img src="notes/image-20200317165018935-1603867370946.png" style="zoom:50%;" />



| 状态值    | 含义                                   |
| --------- | -------------------------------------- |
| absent    | 卸载软件包                             |
| installed | 安装软件包                             |
| latest    | 更新软件包、若无安装则会自动安装软件包 |
| pressent  | 安装软件版                             |
| removed   | 卸载软件包                             |

yum模块的参数功能很多，如上是常用的参数



【yum模块批量安装nginx】

```shell
1.检查客户端机器是否安装了nginx
[root@Ansible ~]# ansible syh -m shell -a 'rpm -qa nginx warn=False'
192.168.37.200 | CHANGED | rc=0 >>

192.168.37.201 | CHANGED | rc=0 >>

192.168.37.202 | CHANGED | rc=0 >>



2.通过yum模块批量安装软件
[root@Ansible ~]# ansible syh -m yum -a 'name=nginx state=installed'

其实yum模块，就是远程在节点机器上执行，可以快速登录到节点机器，检查进程
/usr/bin/python /usr/bin/yum -d 2 -y install nginx

3.远程检查ansible命令执行结果
[root@m01 ~]# ansible chaoge -m shell -a "rpm -qa nginx warn=false"
192.168.37.201 | CHANGED | rc=0 >>
nginx-1.16.1-2.el7.x86_64
192.168.37.202 | CHANGED | rc=0 >>
nginx-1.16.1-2.el7.x86_64
192.168.37.200 | CHANGED | rc=0 >>
nginx-1.16.1-2.el7.x86_64


4.远程删除软件包
[root@Ansible ~]# ansible syh -m yum -a 'name=nginx state=absent'
[root@Ansible ~]# ansible syh -m shell -a 'rpm -qa nginx warn=False'
192.168.37.201 | CHANGED | rc=0 >>

192.168.37.200 | CHANGED | rc=0 >>

192.168.37.202 | CHANGED | rc=0 >>


5.升级nginx软件包
[root@Ansible ~]# ansible syh -m yum -a 'name=nginx state=latest'


6.升级系统所有软件包，排除某些服务
[root@Ansible ~]# ansible syh -m yum -a "state=latest name='*' exclude='nginx'"
```



### **7.13Ansible模块之systemd管理****

**==service/systemd模块==**

该模块作用是针对yum包管理

service适用于centos6前的系统

systemd命令应用于centos7系统

**要注意的是service模块依旧对centos7有效，但是建议大家使用systemd模块**



```shell
如果使用systemctl 管理程序的话，可以使用systemd模块，systemctl 可以 控制程序启/停，reload，开机启动，观察程序状态（status）等，掌握使用后管理就更方便了

主要参数
name: 服务名，例如crond.service，最好带上后缀.service
state: 需要的操作，reloaded, restarted, started, stopped
enabled：是否需要开机启动
daemon_reload：systemd 读取配置文件，每次修改了文件，最好都运行一次，确保应用了
```

==**管理crond定时任务服务**==

```shell
1.一条命令快速检查 所有客户端机器，crond服务是否启动
[root@Ansible ~]# ansible syh -m shell -a 'systemctl status crond|grep Active:'

[root@Ansible ~]# ansible syh -m shell -a 'systemctl status crond|grep Active:'
192.168.37.202 | CHANGED | rc=0 >>
   Active: active (running) since 五 2020-10-16 09:25:25 CST; 4min 41s ago
192.168.37.200 | CHANGED | rc=0 >>
   Active: active (running) since 五 2020-10-16 09:25:32 CST; 4min 33s agoWarning: crond.service changed on disk. Run 'systemctl daemon-reload' to reload units.
192.168.37.201 | CHANGED | rc=0 >>
   Active: active (running) since 五 2020-10-16 09:25:29 CST; 4min 36s agoWarning: crond.service changed on disk. Run 'systemctl daemon-reload' to reload units.


2.检查所有crond服务是否开机自启
[root@Ansible ~]# ansible syh -m shell -a "systemctl list-unit-files" | grep crond
crond.service                                 enabled 
crond.service                                 enabled 
crond.service                                 enabled 


3.systemd管理服务
ansible chaoge -m systemd -a "name=crond state=stopped"		停止crond服务
ansible chaoge -m systemd -a "name=crond state=started"		开启crond服务
ansible chaoge -m systemd -a "name=crond state=restarted"	重启crond服务
ansible chaoge -m systemd -a "name=crond state=reloaded"	平滑启动crond服务
```

**==管理nginx服务，启动nginx，添加至开机自启==**

```shell
1.命令如下
[root@Ansible ~]# ansible syh -m systemd -a 'name=nginx enabled=yes state=started'

停止服务
ansible chaoge -m systemd -a "name=nginx state=stopped"

重启
ansible chaoge -m systemd -a "name=nginx state=restarted"

重载
ansible chaoge -m systemd -a "name=nginx state=reloaded"

2.检查命令执行结果
服务器是否启动
[root@Ansible ~]#  ansible syh -m shell -a "systemctl status nginx" |grep Active
   Active: active (running) since 五 2020-10-16 10:00:34 CST; 2min 4s ago
   Active: active (running) since 五 2020-10-16 10:00:34 CST; 2min 4s ago
   Active: active (running) since 五 2020-10-16 10:00:34 CST; 2min 4s ago


服务是否开机自启
[root@Ansible ~]# ansible syh -m shell -a "systemctl list-unit-files" | grep nginx
nginx.service                                 enabled 
nginx.service                                 enabled 
nginx.service                                 enabled 
```

### **7.14Ansible模块之cron模块**

cron模块作用是管理定时任务的条目

<img src="notes/image-20200317173121859-1603867365278.png" style="zoom:50%;" />



常见的参数如此，使用ansible编写定时任务，和直接编写是没有什么区别的

**==对比系统crontab和ansible模块cron==**

![](notes/image-20200317174549652-1603867362395.png)

==**【ansible批量添加定时任务**】==

```shell
1.批量添加定时任务
[root@Ansible ~]# ansible syh -m cron -a "name=ntp_date job='/usr/sbin/ntpdate ntp.aliyun.com >/dev/null 2>&1' minute=*/5"

2.批量检查定时任务
[root@Ansible ~]# ansible syh -m shell -a 'crontab -l'

3.若要删除定时任务，可以：
[root@Ansible ~]# ansible syh -m cron -a "name=ntp_date state=absent "

4.验证定时任务是否已被删除
[root@Ansible ~]# ansible syh -m shell -a 'crontab -l'

```



### **7.15Ansible模块之user模块**

**==Ansible用户模块==**

==user模块==

user模块管理系统用户

| 模块参数    | 参数描述                         |
| ----------- | -------------------------------- |
| create_home | 创建家目录，设置no则不创建家目录 |
| group       | 创建用户组                       |
| name        | 创建用户的名字                   |
| password    | 创建用户的密码                   |
| uid         | 创建用户的UID                    |
| shell       | 设置能否登录                     |



**==【创建test用户】==**

UID设置8888，禁止登录，禁止家目录生成

```shell
1.创建test用户、并指定uid为8888、禁止登录、禁止家目录生成
[root@Ansible ~]# ansible syh -m user -a 'name=test uid=8888 create_home=no  shell=/sbnin/nologin'

2.查看test用户是否生成
[root@Ansible ~]# ansible syh -m shell -a 'tail -1 /etc/passwd'
192.168.37.202 | CHANGED | rc=0 >>
test:x:8888:8888::/home/test:/sbnin/nologin
192.168.37.200 | CHANGED | rc=0 >>
test:x:8888:8888::/home/test:/sbnin/nologin
192.168.37.201 | CHANGED | rc=0 >>
test:x:8888:8888::/home/test:/sbnin/nologin

[root@Ansible ~]# ansible syh -m shell -a 'ls /home'
192.168.37.202 | CHANGED | rc=0 >>
syh
192.168.37.200 | CHANGED | rc=0 >>
syh
192.168.37.201 | CHANGED | rc=0 >>
syh


```





### **7.16Ansible模块之group模块**

==**Ansible用户组模块**==

**==group模块==**

管理系统用户组

```shell
模块参数    参数描述
name    创建指定的组名
gid        组的GID
state        absent，移除远程主机的组
                present，创建远端主机的组
```

```shell
1.创建一个组
[root@m01 ~]# ansible chaoge -m group -a "name=cc  gid=9999"


2.查看生成的组
[root@Ansible ~]# ansible syh -m shell -a 'tail -1 /etc/group'
192.168.37.200 | CHANGED | rc=0 >>
haha:x:5555:
192.168.37.202 | CHANGED | rc=0 >>
haha:x:5555:
192.168.37.201 | CHANGED | rc=0 >>
haha:x:5555:

```



### **7.17Ansible之playbook剧本介绍**

==**Ansible核心组件playbook**==

Ansible核心功能点就在于`playbook`，Ansible主要的工作都是在于`配置管理`，它在实际的工作中会大量编写和使用剧本。

<img src="notes/image-20200318091032790-1603867356029.png" style="zoom:50%;" />

如果说ansible 模块 是你车间里的工具，那么playbooks 是你的说明书／使用手册，并且资源清单上的主机是你的原材料。

在ansible 上使用Playbooks是一种完全不同于adhoc的任务执行模式，并且特别强大。

简单地说，playbooks是一个非常简单的配置管理和多机器部署系统的基础，以及非常适合部署复杂应用程序的系统。

Playbooks可以对任务进行编排，就像我们要安装一个程序，写个安装shell脚本一样，在哪一步复制配置文件，最后一步启动服务。

虽然/usr/bin/ansible 可以运行一些临时任务，但是针对复杂的配置，并且可以将配置标准化，这个时候就需要Playbooks了。



==Playbook剧本语法==

既然要写剧本，就得按照剧本的格式去编写

【比如一个电影剧本】

<img src="notes/image-20200318091428772-1603867345831.png" style="zoom:50%;" />

【Anisble剧本】

ansible软件的playbook编写需要遵循`YAML`语法，因此我们得先学一下YAML语法结构

**==【playbook安装nginx】==**

1.批量卸载所有的nginx

```shell
[root@Ansible ~]# ansible syh -m yum -a 'name=nginx state=removed'
[root@Ansible ~]# ansible syh -m shell -a 'rpm -qa nginx warn=false'
192.168.37.202 | CHANGED | rc=0 >>
192.168.37.200 | CHANGED | rc=0 >>
192.168.37.201 | CHANGED | rc=0 >>
```

2.查看一个YAML文件，请严格注意

- **==语法的对齐，不得多一个少一个空格==**
- ==**输入法保证英文**==

```shell
[root@m01 scripts]# cat nginx.yaml -n
     1    # install nginx yaml ,by chaoge
     2    - hosts: all
     3      tasks:
     4          - name: Install nginx Package
     5            yum: name=nginx state=present
     6          - name: Copy Nginx.conf
     7            copy: src=./nginx.conf dest=/etc/nginx/nginx.conf mode=0644
```

3.解释如上的playbook代码，按行解释

```shell
1.表示注释信息，可以用#，也可以用 ---  三个短横线
2.定义playbook管理的目标主机，all表示所有的主机，也可以写 主机组名
3.定义playbok所有的任务集合信息，比如该文件，定义了2个任务  ，安装nginx，拷贝nginx配置文件
4.定义了任务的名词，自定义的帮助信息
5.定义任务的具体操作，比如这里用yum模块实现nginx的安装
6.
7.第六、第七两行作用是使用copy模块，把本地当前的nginx.conf配置文件，分发给其他所有客户端机器，且授权
```

通过如上的剧本解读，各位兄弟姐妹们应该已经有了点感觉，其实编写剧本并不是特别复杂的事。我们需要注意如下两点：

- 剧本内容组成规范
- 剧本语法规范

==**playbook内容组成规范**==

刚才说了，剧本就像演员演戏，导演提供的文字资料，因此剧本重要的就是定义`演员的信息`，`演员的任务`

而Ansible的剧本也是由最基本的两个部分组成

- hosts定义剧本管理的主机信息（演员有哪些）
- tasks定义被管理的主机需要执行的任务动作（演员需要做什么事）

<img src="notes/image-20200318094059283-1603867313023.png" style="zoom: 33%;" />

![](notes/微信图片_20201016141133-1603867310159.png)



![](notes/微信图片_20201016141304-1603867306144.png)





### **7.18Ansible剧本规范之hosts定义**

**==【剧本&hosts部分】==**

定义剧本的hosts部分，可以有如下多种方式，常见的有

```shell
# 方式一：定义所管理的主机IP地址
- hosts: 192.168.178.111
  tasks: 
    动作...

# 方式二：定义所管理主机的名字
- hosts: backup01
  tasks:
    动作...

# 方式三：定义管理主机
- hosts: 192.168.178.111, rsync01
  tasks:
    动作...

# 方式四：管理所有主机
- hosts: all
  tasks:
    动作...
```

定义剧本管理主机信息有一个重要的前提，就是被管理的主机，必须在Ansible主机清单文件中定义

也就是默认的`/etc/ansible/hosts`，否则剧本无法直接管理对应主机。

### **7.19Ansible剧本规范之tasks**

**==【剧本&tasks部分】==**

- 变量形式定义task任务
- 字典形式定义任务

```shell
# 方式一：采用变量格式设置任务
tasks:
  - name: make sure apache is running
    service: name=https state=running
# 当传入的参数列表过长时，可以将其分割到多行
tasks:
  - name: copy ansible inventory(清单) file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
          owner=root group=root mode=0644

# 方式二：采用字典格式设置多任务
tasks:
   - name: copy ansible inventory file to client
     copy:
         src: /etc/ansible/hosts
         dest: /etc/ansible/hosts
         owner: root
         group: root
         mode: 0644
```

### **7.20Ansible之YAML语法介绍**

==**yaml语法**==

```shell
在学习saltstack过程中，第一要点就是States编写技巧，简称SLS文件。这个文件遵循YAML语法。初学者看这玩意很容易懵逼，来，超哥拯救你学习YAML语法
json xml yaml 数据序列化格式
yaml容易被解析，应用于配置文件

salt的配置文件是yaml配置文件，不能用tab
saltstack,k8s,ansible都用的yaml格式配置文件


语法规则
    大小写敏感
    使用缩进表示层级关系   
    缩进时禁止tab键，只能空格
    缩进的空格数不重要，相同层级的元素左侧对其即可
    # 表示注释行
yaml支持的数据结构
    对象： 键值对，也称作映射 mapping 哈希hashes 字典 dict    冒号表示 key: value   key冒号后必须有
    数组： 一组按次序排列的值，又称为序列sequence 列表list     短横线  - list1
    纯量： 单个不可再分的值

对象：键值对
yaml
    first_key:
      second_key:second_value

python
    {
        'first_key':{
            'second_key':'second_value',
        }
    }
```

==**playbook编写语法规范**==

剧本编写，初学者最头疼的问题就是`没遵循语法`

==**剧本编写缩进**==

编写剧本要注意不同的行信息之间需要有缩进关系，一般是两个空格作一个缩进

**注意一句话：空格数目无所谓，左侧对其即可**

```shell
- hosts: chaoge
  tasks:
- name: exec scripts
  script: /server/scripts/chaoge.sh
```

**==剧本编写字典规范==**

编写剧本时，有时需要定义变量信息，或是模块参数，可以用字典形式设置

字典数据格式：注意key和value之间有一个冒号+空格

```shell
key: value
```

是一个key对应一个value值，好比是下图

<img src="notes/image-20200318101658864-1603868097002.png" style="zoom:50%;" />

具体的playbook案例

```shell
- hosts: chaoge
  tasks:
- name: create file
  file:
    path: /chaoge/666.txt
    state: directory
    mode: 644
    owner: chaoge
    group: chaoge
```

**==剧本编写列表规范==**



列表数据结构，如图

<img src="notes/image-20200318102240082-1603867283789.png" style="zoom:50%;" />

在编写剧本的时候，剧本中有些信息比较相近，且缩进关系保持一致

例如高中一班，有男同学，女同学之分

男同学的成员成为一列

女同学的成员成为一列

【yaml数据结构如下】

```shell
"男同学": 
  - 张三
  - 李四
  - 王二麻
"女同学":
  - 花花
  - 月月
  - 兔兔


列表数据用一个短横杠+空格组成
```

### **7.21Ansible剧本执行实践**

**==playbook执行命令==**

剧本编写完毕后，得执行才能开始工作。

在Ansible程序里，加载模块的功能可以直接用ansible命令操作

加载剧本中的功能，可以使用`ansible-playbook`命令：

```shell
ansible-playboook nginx.yaml
```

可以用相对、绝对路径

【查看剧本执行详细输出】

```shell
ansible-playbook nginx.yml --verbose
```

【查看剧本执行影响的主机列表】

```shell
ansible-playbook nginx.yml --list-hosts
```

【执行playbook指定加载的主机清单文件】

```shell
ansible-playbook nginx.yml -i /etc/ansible/hosts
```

【执行playbook时检查剧本语法】

```shell
ansible-playbook nginx.yml --syntax-check
```

【调试playbook任务，模拟执行，不影响主机配置】

```shell
ansible-playbook nginx.yml -C
```

**【playbook的输出信息】**

剧本执行过程中会产生响应的输出，根据输出的信息可以掌握剧本是否正确执行，根据输出的措施信息，可以掌握剧本中编写的逻辑错误。

```shell
脚本文件内容
[root@Ansible myscripts]# cat test_playbook.yaml 
#Thiis is syh's test playbook;  Install nginx 

- hosts: syh
  tasks:
    - name: install nginx
      yum: name=nginx state=installed
    - name: copy nginx.conf to every_server
      copy: src=./nginx.conf dest=/opt 

脚本调试
[root@Ansible myscripts]# ansible-playbook test_playbook.yaml -C

```

![](notes/微信图片_20201016142142-1603867268021.png)

```
当本地执行了任务，会得到返回值changed
如果不需要执行了，得到返回值ok
```

【剧本输出的字段信息】

| 字段                  | 输出解释                                                     |
| --------------------- | ------------------------------------------------------------ |
| play[all]             | 显示执行过程中加载的客户端主机或组信息                       |
| TASK[Gathering Facts] | 显示对客户端主机执行的任务信息，默认是是先收集主机信息       |
| TASK[xxxx]            | 显示对客户端主机具体执行的任务，默认加载模块命令，显示name定义的值 |
| PLAY RECAP            | 剧本执行结果汇总，对主机的改动次数，出现的错误等信息         |





**7.22Ansible剧本之部署rsync服务端**

【环境准备】

```
1.保证管理机器存在配置好的rsyncd.conf配置文件和rsync.password密码文件；
```



```shell
1.创建剧本内容
[root@Ansible myscripts]# vim ./test_rsync.yaml

#rsync_setup,by syh

#by syh, rsync_service 
- hosts: syh
  tasks:
    - name: no1 install rsync
      yum:
          name: rsync
          state: installed
    - name: no2 create user rsync and setup nologin don't create home
      user:
          name: rsync
          create_home: no
          shell: /sbin/nologin
    - name: no3 crate /rsync_dir and set uid gid
      file:
          path: /rsync_dir
          state: directory
          owner: rsync
          group: rsync
    - name: no4 copy password file to every_server
      copy:
        src: /etc/rsync.password
        dest: /etc/rsync.password

    - name: no5 copy rsyncd.conf to every_server
      copy:
        src: /etc/rsyncd.conf
        dest: /etc/rsyncd.conf

    - name: no6 start rsync.service
      systemd:
          name: rsyncd
          state: reloaded

```



### **7.22Ansible之扩展知识**

==**playbook扩展配置**==

==**playbook中变量形式**==

在剧本中通过设置变量，实现对应的参数配置，在某些场景下，需要对剧本进行优化调整。

剧本中定义变量如下：

- playbook中用户自定义的变量
- ansible自动在执行playbook时去客户机上搜集远程主机的系统信息变量
- 在文件模板中，可以直接用如上的变量
- 把任务的运行结果当做变量使用，称之为注册变量
- 允许用户在执行playbook时传入变量的值，称之为额外变量

**==用户自定义的变量==**

playbook中定义变量

用户可以在playbook中通过`vars`关键字定义变量，之后在通过`{{}}`符号调用变量值。

实际操作

在剧本文件中，用户自定义变量http_port，值为80。在tasks的firewalld中，可以通过调用变量值。

```shell
- hosts: web
  vars:
      http_port: 80
  remote_user: root
  tasks:
      - name: insert firewalld rule for httpd
        firewalld: port={{ http_port }}/tcp permanent=true state=enabled imme-diate=yes
```

==**变量单独写在文件里**==

当变量较多、或是变量需要在多个playbook中重复使用的时候，可以把变量放在一个单独的文件中，再通过关键字`var_files`把该变量引入到playbook中，使用变量的方法和文件中定义的方法相同。

```shell
- hosts: web
  vars_files:
      - vars/server_vars.yml
  remote_user: root
  tasks:
      - name: insert firewalld rule for httpd
        firewalld: port={{ http_port }}/tcp permanent=true state=enabled immediate=yes
```

变量文件`/vars/server_vars.yml`的内容为，可以交给多个剧本文件去读取

```shell
http_port: 80
```

==**定义、使用复杂的变量**==

在某些场景下需要使用变量的值，可能不仅仅是一个简单的`字符串`或是`数字`，而是一个`对象`。

对象在yaml数据结构中如下：

对象就是一个字典形式数据结构

```shell
foo:
    field1: one
    field2: tow
```

如果要访问复杂变量中的子属性，可以使用`中括号`或是`点`，代码如下

若是大家学过编程语言，例如python的dict字典数据结构，对于yaml的理解就非常简单了

```
foo['field1']
foo.field2
```

**==远程主机的系统变量（Facts）==**

ansible能够通过模块`setup`来搜集主机的系统信息，这些搜集到的信息被称之为Facts。

每个playbook在执行前都会默认执行setup模块，自动收集客户机信息，这些Facts信息可以直接以变量的形式使用。

【可以通过命令直接在命令行调用setup模块，查看所有可以调用的Facts变量信息。】

```shell
[root@m01 scripts]# ansible 192.168.178.111  -m setup -u root  # 指定ip
[root@m01 scripts]# ansible chaoge  -m setup -u root                     # 指定主机组
[root@m01 scripts]# ansible all  -m setup -u root                             # 指定所有主机
```

【在剧本中调用收集到的Facts变量信息】

该脚本能够判断，不同的主机信息，进行不同的软件包安装

when相当于shell脚本里的if 判断，when语句就是用来实现这个功能的，它是一个jinja2的语法，但是不需要双大括号，用法很简单

```shell
- hosts: all
  user: root
  tasks:
      - name: print system info 
        debug: msg={{ ansible_os_family }}
      - name: install git on redhat linux
        yum: name=git state=installed
        when: ansible_on_family == "redhat"
      - name: install git on ubuntu linux
        apt: name=git state=installed
```

**使用复杂的Facts变量**

当通过setup模块收集到主机信息时，有些Facts变量属性较为复杂，例如

【setup参数】

```shell
选项    作用
ansible_python_version    显示python版本
ansible_distribution_major_version    显示是系统主版本
ansible_machine    显示系统类型，例：32位，还是64位
ansible_all_ipv4_addresses    仅显示ipv4的信息
ansible_devices    仅显示磁盘设备信息
ansible_distribution    显示是什么系统
ansible_eth0    仅显示eth0的信息
ansible_kernel    仅显示内核版本
ansible_lvm    显示lvm相关信息
ansible_memtotal_mb    显示系统总内存
ansible_memfree_mb    显示可用系统内存
ansible_memory_mb    详细显示内存情况
ansible_mounts    显示系统磁盘挂载情况
ansible_processor    显示cpu个数(具体显示每个cpu的型号)
ansible_processor_vcpus    显示cpu个数(只显示总的个数)
ansible_swaptotal_mb    显示总的swap内存
ansible_swapfree_mb    显示swap内存的可用内存
# 单独筛选网卡信息
[root@m01 scripts]# ansible chaoge -m setup -u root  -a "filter=ansible_all_ipv4_addresses"
```

若是要访问复杂变量的子属性，有两种方式，这其实都是python的jinja2模块语法，可以写在playbook里使用

```shell
1.中括号调用
{{ ansible_ens33["ipv4"]["address"] }}

2.点号调用
{{ ansible_ens33.ipv4.address }}
```

==**文件模板中使用变量**==

这里要讲的是template模块

`template`模块使用了[`Jinjia2`模版语言](http://jinja.pocoo.org/docs/)，进行文档内变量的替换的模块。

template模块用法和copy模块用法基本一致，它主要用于复制配置文件。可以按需求修改配置文件内容来复制模板到被控主机上。

模版中可以使用如下6个变量：

- `ansible_managed` - 包含一个字符串，可用于描述模板名称，主机，模板文件的修改时间和所有者的uid
- `template_host` - 包含模板机器的节点名称
- `template_uid` - 所有者的uid
- `template_path` - 模版路径
- `template_fullpath` - 模版的绝对路径
- `template_run_date` - 模版呈现的时间

【模块参数】

|          名称          | 必选 | 默认值 | 可选值           | 备注                                                         |
| :--------------------: | :--: | :----- | :--------------- | :----------------------------------------------------------- |
|         backup         |  no  | no     | `yes`/`no`       | 在覆盖之前将原文件备份，备份文件包含时间戳信息               |
|         follow         |  no  | no     | `yes`/`no`       | 是否遵循目的机器中的文件系统链接                             |
|         force          |  no  | yes    | `yes`/`no`       | 是否强制执行                                                 |
|         group          |  no  |        |                  | 设置文件/目录的所属组                                        |
|          mode          |  no  |        |                  | 设置文件权限，模式实际上是八进制数字（如`0644`），少了前面的零可能会有意想不到的结果。从版本1.8开始，可以将模式指定为符号模式（例如`u+rwx`或`u=rw,g=r,o=r`） |
| newline_sequence(2.4+) |  no  | `\n`   | `\n`,`\r`,`\r\n` | 指定要用于模板文件的换行符                                   |
|         owner          |  no  |        |                  | 设置文件/目录的所属用户                                      |
|          src           |  no  |        |                  | Jinja2格式化模板的文件位置                                   |
|      trim_blocks       |  no  | no     | `yes`/`no`       | 设置为True，则块之后的第一个换行符被移除                     |
|     unsafe_writes      |  no  |        | `yes`/`no`       | 是否以不安全的方式进行，可能导致数据损坏                     |
|        validate        |  no  | None   |                  | 复制前是否检验需要复制目的地的路径                           |

【建立模板文件】

```shell
[root@m01 scripts]# cat index.html.j2
Hello "{{ chaoge_var }}"
```

- 由于Ansible是使用`Jinja2`来编写`template`模版的，所以需要使用`*.j2`为文件后缀
- 上面的`""`代表我们在该template里使用了名为`chaoge_var`的变量

【编写playbook，加入变量】

```shell
[root@m01 scripts]# cat template_demo.yml
---
- name: play the template module
  hosts: all
  vars:
    chaoge_var: "world,I am yuchao"
  tasks:
    - name: write the default index.html file
      template:
        src: index.html.j2
        dest: /tmp/hello_world.html
        mode: 0644
```

【执行剧本】

```shell
[root@m01 scripts]# ansible-playbook template_demo.yml

PLAY [play the template module] **********************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [192.168.178.110]
ok: [192.168.178.111]

TASK [write the default index.html file] *************************************************************
changed: [192.168.178.110]
changed: [192.168.178.111]

PLAY RECAP *******************************************************************************************
192.168.178.110            : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
192.168.178.111            : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

【验证剧本执行结果】

发现写在j2模板文件中的变量已经被替换

```shell
[root@m01 scripts]# ansible chaoge  -a "cat /tmp/hello_world.html"
192.168.178.111 | CHANGED | rc=0 >>
Hello "world,I am yuchao"
192.168.178.110 | CHANGED | rc=0 >>
Hello "world,I am yuchao"
```